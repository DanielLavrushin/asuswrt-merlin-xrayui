{
  "labels": {
    "import": "import",
    "connect": "connect",
    "reconnect": "reconnect",
    "start": "start",
    "restart": "restart",
    "stop": "stop",
    "show_config": "show config",
    "manage": "manage",
    "add": "add",
    "delete": "delete",
    "server": "server",
    "client": "client",
    "transport": "transport",
    "sniffing": "sniffing",
    "apply": "apply",
    "close": "close",
    "cancel": "cancel",
    "accept": "accept",
    "save": "save",
    "edit": "edit",
    "reorder": "move up",
    "renew": "renew",
    "regenerate": "regenerate",
    "enabled": "enabled",
    "disabled": "disabled",
    "items": "items: {0}",
    "help": "help",
    "xrayui_desc": "This UI control page provides a simple interface to manage and monitor the X-ray Core's configuration and it's status."
  },
  "guide": {
    "dns_leak": "https://daniellavrushin.github.io/asuswrt-merlin-xrayui/en/dns-leak"
  },
  "com": {
    "ClientStatus": {
      "configuration": "Configuration",
      "connection_status": "Connection status",
      "general_options": "General options",
      "xray_connecting": "Checking connection...",
      "xray_connected": "XRAY is connected",
      "xray_stopped": "XRAY is stopped",
      "xray_running": "XRAY service is running"
    },
    "ServerStatus": {
      "configuration": "Configuration",
      "connection_status": "Connection status",
      "general_options": "General options",
      "xray_connecting": "Checking connection...",
      "xray_connected": "XRAY is connected",
      "xray_stopped": "XRAY is stopped",
      "xray_running": "XRAY service is running"
    },
    "GeneralOptionsModal": {
      "modal_title": "XRAYUI General Settings",
      "check_xray_connection": "Check connection to xray server",
      "start_xray_on_reboot": "Start X-RAY on router reboot",
      "modalConnectTitle": "XRAY Connection Check",
      "modalConnectCheckDescription": "<p>This option verifies that the actual connection is working by sending a request to <a href=\"https://ip-api.com/\" target=\"_blank\">ip-api.com</a> through the outbound proxy at startup.</p><p>XRAYUI will insert a system rule into the routing rules and create a SOCKS inbound proxy for this check. These system settings are tagged with <code>sys</code> and will remain hidden in the UI.</p>",
      "logs_header": "Logs",
      "label_logs_enable_access": "Enable access logs",
      "label_logs_enable_error": "Enable error logs",
      "label_logs_enable_dns": "Enable DNS logs",
      "label_logs_level": "Log level",
      "label_probe_url": "Observatory probe URL",
      "hint_probe_url": "The URL used by the Xray Observatory to probe outbound health. The endpoint should return HTTP 204 (No Content).",
      "label_gh_proxy": "Use GitHub Proxy",
      "hint_gh_proxy": "Use a GitHub proxy to download files from GitHub (Xray updates, geodata files, etc.) when GitHub is blocked in your region.",
      "geodad_header": "GeoIP/GeoSite Metadata",
      "label_geoip_url": "GeoIP dat URL",
      "label_geosite_url": "GeoSite dat URL",
      "wellknown_geodata": "Use well-known geodata",
      "label_logs_enable_dnsmasqlog": "Enable dnsmasq logs",
      "hint_logs_enable_dnsmasqlog": "Enabling this will make the logs show domain names rather than IP addresses.",
      "label_logs_max_size": "Max log size",
      "hint_logs_max_size": "The maximum size of the log file (in megabytes). When the log file exceeds this size, it will be automatically rotated.",
      "label_logs_dor": "Clear logs on xray restart",
      "label_geosite_autoupdate": "Auto-update geodata files",
      "label_skip_test": "Skip testing  XRAY",
      "hint_skip_test": "If you don't want to validate the XRAY configuration file, you can skip this step. However, it's recommended to keep it enabled to ensure the configuration file is valid.<hr/>The test step can consume some resources, so it may be advisable to disable it if you're using a low-performance router.",
      "label_clients_check": "Check clients online status",
      "hint_clients_check": "If you enable this option, XRAYUI will check the connected clients online status.<hr/>This option is useful for keeping track of which clients are currently connected to the xray.<hr/> However, it may consume some resources, so it may be advisable to disable it if you're using a low-performance router.",
      "label_enable_debug": "Enable debug logs",
      "label_ipset": "Enable DNS bypass (ipset)",
      "hint_ipset": "*OFF* - turns off the DNS → ipset feature; routing behaves exactly as if the option didn’t exist.<hr />*BYPASS* - domains you mapped to the `FREEDOM` outbound go straight to the internet, skipping Xray; every other domain is still proxied.<hr/>*REDIRECT* – the inverse: only domains not mapped to `FREEDOM` are proxied; all other traffic leaves the router directly.<blockquote>Important: `regexp`-based domains can’t be pushed into an ipset, so they’re ignored here.</blockquote>",
      "startup_delay": "XRAYUI Startup delay",
      "hint_startup_delay": "After the router restarts, XRAYUI will start after the specified time (in seconds). This can help avoid issues with XRAY hanging on startup.",
      "sleep_time": "After XRAY start delay",
      "hint_sleep_time": "XRAYUI will wait for the specified time (in seconds) after starting XRAY before proceeding with further actions (applying firewall rules etc.).",
      "tab_general": "General",
      "tab_geodata": "Geodata",
      "tab_logs": "Logs",
      "tab_hooks": "Hooks",
      "label_hooks_before_firewall_start": "Before firewall start",
      "label_hooks_after_firewall_start": "After firewall start",
      "label_hooks_after_firewall_cleanup": "After firewall cleanup",
      "hint_hooks_before_firewall_start": "This script will be executed before the firewall starts. You can use it to set up any custom rules to iptables.<hr/> Don't add she-bang (`#!/bin/sh`) to the script, it will be added automatically.",
      "hint_hooks_after_firewall_start": "This script will be executed after the firewall starts. You can use it to set up any custom rules to iptables.<hr/> Don't add she-bang (`#!/bin/sh`) to the script, it will be added automatically.",
      "hint_hooks_after_firewall_cleanup": "This script will be executed after the firewall cleanup. You can use it to clean up any custom rules to iptables.<hr/> Don't add she-bang (`#!/bin/sh`) to the script, it will be added automatically.",
      "tab_subscriptions": "Subscriptions",
      "label_subscription_links": "Subscription Sources",
      "hint_subscription_links": "Here you can add your subscription sources.<hr/> It is possible to add multiple links, one per line.<hr/> You need to press `fetch` button to fetch the subscription links from the sources.<hr/> After that you can select the subscription outbound in the  outbound settings.",
      "button_subscription_fetch": "fetch",
      "tab_dns": "DNS",
      "label_dns_leak": "Prevent DNS leaks",
      "hint_dns_leak": "Enable this option to prevent DNS leaks.<blockquote>**Important!** Do not turn this option `on` without proper xray configuration. Click help next to the checkbox to learn more about DNS leaks and how to configure them properly.</blockquote>",
      "label_logs_scribe": "Integrate XRAYUI logs with Scribe",
      "hint_logs_scribe": "Enabling this option will integrate XRAYUI logs with `Scribe`. This allows you to view XRAYUI logs in the `Scribe` web interface in a dedicated window.<hr/>You can install `Scribe` from the `AMTM`",
      "label_subscription_auto_refresh": "Auto-refresh subscriptions",
      "hint_subscription_auto_refresh": "Periodically re-fetch subscription sources to keep the endpoint pool up to date.",
      "sub_refresh_3h": "Every 3 hours",
      "sub_refresh_6h": "Every 6 hours",
      "sub_refresh_12h": "Every 12 hours",
      "label_subscription_auto_fallback": "Auto-fallback",
      "hint_subscription_auto_fallback": "When enabled, outbounds with the auto-fallback option will be periodically checked and automatically rotated to an alive endpoint if the current one is unreachable.",
      "label_subscription_fallback_interval": "Health check interval",
      "hint_subscription_fallback_interval": "How often to check the health of pool-managed outbounds.",
      "warn_auto_fallback_requires_observatory": "Requires Xray Connection Check to be enabled in the General tab.",
      "label_subscription_filters": "Rotation Filters",
      "hint_subscription_filters": "Filter subscription links for auto-failover rotation by name.<hr/>Enter comma-separated keywords (e.g. <code>Canada, Denmark</code>).<hr/>Only links whose name contains at least one keyword will be used.<hr/>If empty, the full subscription pool is used.",
      "placeholder_subscription_filters": "e.g. Canada, Denmark, Japan"
    },
    "ImportConfig": {
      "import_config_file": "Import config file"
    },
    "ImportConfigModal": {
      "modal_title": "Import configuration",
      "modal_desc": "Here you can import a configuration from a QR code or a protocol URL.",
      "label_qr_code": "QR code",
      "label_proxy_uri": "Outbound Proxy Uri",
      "label_complete_setup": "I'd like to have a complete setup!",
      "hint_qr_code": "Try to print screen your QR code and xrayui will try to read it.",
      "hint_proxy_uri": "You can paste here the URL of the protocol here. Usually they start with `vless://` or `vmess://`.",
      "hint_complete_setup": "If you select this option, xrayui will overwrite your current configuration with the most suitable default configuration for the imported protocol.<hr />A default Routing rule will be created to test the proxy outbound connection. After importing and applying the configuration, you can try to open the `https://ip-api.com/`. You should see the IP of the server you are connected to.<hr />After that, it is recommended to set up your own traffic routing rules.",
      "label_routing_mode": "Routing mode",
      "hint_routing_mode": "Choose how to configure routing rules for your imported configuration.<hr/><b>Basic bypass</b>: Creates routing rules for the most common services (Google, Meta, Telegram, Twitter, Discord, TikTok, Netflix, Github, Cloudflare). Traffic to these services will go through the proxy.<hr/><b>No routing rules</b>: No routing rules will be created. All traffic will go to the first outbound (direct) unless you configure rules manually.<hr/><b>Keep existing rules</b>: Preserves your current routing rules. Use this if you already have custom rules configured.",
      "opt_routing_basic": "Basic bypass (Recommended)",
      "opt_routing_none": "No routing rules",
      "opt_routing_keep": "Keep existing routing rules",
      "label_import_type": "Import type",
      "opt_qr": "QR code",
      "opt_url": "URL",
      "opt_json": "JSON",
      "opt_file": "Restore from File",
      "label_proxy_json": "Import JSON",
      "label_proxy_file": "Restore from File",
      "hint_proxy_json": "You can paste the contents of a JSON file here. XRAYUI will modify the configuration to ensure compatibility with the router.",
      "hint_proxy_file": "Select the JSON file you want to import.<hr/> Use this option only if you are re-uploading a previously working configuration and are certain it works on your router. <hr/> If you want to ensure compatibility with your router, please use the `Import JSON` option instead.",
      "alert_qr_decode_error": "Failed to decode QR code.",
      "alert_not_supported_protocol": "Parse of this protocol is not supported yet",
      "alert_complete_setup": "You have selected a complete setup. This will overwrite your current configuration. Are you sure you want to proceed?",
      "alert_invalid_json": "The JSON you provided is invalid. Please check the syntax and try again.",
      "alert_import_success": "Configuration imported successfully."
    },
    "ConfigModal": {
      "modal_title": "Show XRAY configuration file",
      "hide_sensetive_data": "hide sensitive data",
      "open_raw": "open raw",
      "save_to_file": "save to file",
      "alert_copy_ok_hiddendata": "Configuration copied to clipboard. Sensitive data has been hidden. However, please review the configuration before sharing.",
      "alert_copy_ok_nohiddendata": "Configuration copied to clipboard. Warning: Sensitive data is visible. Please be cautious when sharing."
    },
    "Dns": {
      "title": "DNS",
      "label_tag": "Tag",
      "label_hosts": "Hosts",
      "label_servers": "Servers",
      "label_client_ip": "Client IP",
      "label_query_strategy": "Query strategy",
      "label_disable_cache": "Disable cache",
      "label_disable_fallback": "Disable fallback",
      "label_fallback_if_match": "Fallback if match",
      "hint_title": "The DNS module built into Xray has two main purposes:<ul><li>During the routing phase, it resolves domain names to IP addresses and performs traffic splitting based on the results of domain name resolution and the value of domainStrategy in the routing configuration module. The built-in DNS server is only used for DNS queries when either of the following values is set:<ul><li>**IPIfNonMatch**: When a domain name is requested, it first tries to match it against the domain entries in the routing configuration. If no match is found, the built-in DNS server is used to perform a DNS query for the domain name, and the returned IP address is used to perform IP routing matching again.</li><li>**IPOnDemand**: When a domain name is matched against any IP-based rule, it is immediately resolved to an IP address for matching.</li></ul></li><li>It resolves the target address for connection.</li><li>In the freedom outbound setting, if **domainStrategy** is set to **UseIP**, request through the outbound proxy will first resolve the domain name to an IP address using the built-in server before making the connection.</li><li>In the sockopt setting, if **domainStrategy** is set to **UseIP**, system connections initiated through the outbound proxy will first be resolved to an IP address using the built-in server before making the connection.</li></ul>",
      "hint_tag": "Traffic generated by built-in **DNS**, except for localhost, fakedns, **TCPL**, **DOHL**, and **DOQL** modes, can be matched with `inboundTag` in routing using this identifier.",
      "hint_hosts": " A list of static `IP addresses`, with values consisting of a series of domains and addresses. The address can be an IP or a domain name. When resolving a domain name, if the domain name matches an item in this list:<ul><li>If the address of the item is an IP, the resolution result will be that IP.</li><li>If the address of the item is a domain name, this domain name will be used for IP resolution instead of the original domain name.</li><li>If multiple IPs and domain names are set in the address, only the first domain name will be returned, and the rest of the IPs and domain names will be ignored.</li></ul>",
      "hint_servers": " A list of DNS servers. The address can be an IP or a domain name. When resolving a domain name, the DNS server will be used for resolution.",
      "hint_client_ip": "Used to notify the server of the specified IP location during `DNS` queries. Cannot be a private address.",
      "hint_query_strategy": "`UseIPv4` only queries A records; `UseIPv6` only queries `AAAA` records. The default value is `UseIP`, which queries both `A` and `AAAA` records.",
      "hint_disable_cache": "`true` disables DNS caching, default is `false` which means caching is not disabled.",
      "hint_disable_fallback": "`true` disables fallback DNS queries, default is `false` which means fallback queries are not disabled.",
      "hint_fallback_if_match": "`true` disables fallback DNS queries when the matching domain list of the DNS server is hit, default is `false` which means fallback queries are not disabled."
    },
    "Routing": {
      "title": "Routing",
      "label_domain_strategy": "Domain strategy",
      "label_domain_matcher": "Domain matcher",
      "label_policies": "Redirect/Bypass Policies",
      "label_rules": "Rules",
      "label_geodat_metadata": "GeoIp/GeoSite Metadata",
      "manage_local_files": "manage local files",
      "update_community_files": "update community files",
      "hint_title": "The routing module can send inbound data through different outbound connections according to different rules to achieve on-demand proxying. <p>A common use case is to split domestic and foreign traffic. Xray can use its internal mechanisms to determine the traffic from different regions and then send them to different outbound proxies.</p>",
      "hint_domain_strategy": "The domain name resolution strategy, which uses different strategies based on different settings.<ul><li>**AsIs**: Use only the domain name for routing selection. Default value.</li><li> **IPIfNonMatch**: If the domain name does not match any rule, resolve the domain name into an IP address (A record or AAAA record) and match it again<ul><li>When a domain name has multiple A records, it will try to match all A records until one of them matches a rule</li><li>The resolved IP only works for routing selection, and the original domain name is still used in the forwarded packets</li></ul></li><li>**IPOnDemand**: If any IP-based rules are encountered during matching, immediately resolve the domain name into an IP address for matching</li></ul>",
      "hint_domain_matcher": "The domain name matching algorithm, which uses different algorithms based on different settings. This option affects all RuleObject that do not have a separately specified matching algorithm.<ul><li>**hybrid**: Use the new domain name matching algorithm, which is faster and takes up less space. Default value.</li> <li>**linear**: Use the original domain name matching algorithm.</li> </ul>",
      "hint_policies": "Configure per-device routing policies (bypass or redirect) for Xray. You can specify MAC addresses, modes (`bypass` or `redirect`), and ports to fine-tune how traffic is handled.",
      "hint_rules": "An array corresponding to a list of rules. For each connection, the routing will judge these rules from top to bottom in order. When it encounters the first effective rule, it will forward the connection to the outboundTag or balancerTag specified by the rule. <blockquote>When no rules match, the traffic is sent out by the first outbound by default.</blockquote>",
      "hint_geodat_metadata": "Update the GeoIP and GeoSite metadata files. This operation will take some time, please be patient.",
      "hint_ports_policy": "By default, the mode `redirect` is used, meaning that traffic on all ports is redirected to the inbound port of xray. Specify any additional ports that should be routed through or bypass Xray. <ul> <li><strong>redirect</strong>: Traffic on all ports is redirected to the inbound port. You define the ports that should NOT be redirected to Xray.</li> <li><strong>bypass</strong>: Traffic on all ports bypasses Xray. You define the ports that should be explicitly redirected to Xray.</li> </ul>"
    },
    "PolicyModal": {
      "modal_title2": "Policy List",
      "rule_no": "policy #{0}",
      "no_rules_defined": "No policies defined",
      "label_friendly_name": "Friendly name",
      "label_mac": "Devices",
      "label_show_all": "Show all devices",
      "modal_title": "Bypass/Redirect Policy",
      "modal_desc": " By default, the mode <strong>redirect</strong> is used, meaning that traffic on all ports is redirected to the inbound port of xray. Specify any additional ports that should be routed through or bypass Xray. <ul> <li> <strong>redirect</strong>: Traffic on all ports is redirected to the inbound port. You define the ports that should NOT be redirected to Xray. </li> <li> <strong>bypass</strong>: Traffic on all ports bypasses Xray. You define the ports that should be explicitly redirected to Xray. </li> </ul>",
      "label_mode": "Mode",
      "label_tcp_ports": "TCP ports",
      "label_udp_ports": "UDP ports",
      "label_wellknown_ports": "Apply well-known service ports",
      "hint_friendly_name": "A friendly name for the rule.",
      "hint_mode": "The mode of the policy. <ul> <li> <strong>redirect</strong>: Traffic on all ports is redirected to the inbound port. You define the ports that should NOT be redirected to Xray. </li> <li> <strong>bypass</strong>: Traffic on all ports bypasses Xray. You define the ports that should be explicitly redirected to Xray. </li> </ul>",
      "hint_tcp_ports": "Only allowed characters are numbers, commas, and dashes. You may use a new line for each port.<hr />Example: 80,443,8080,1000-2000",
      "hint_udp_ports": "Only allowed characters are numbers, commas, and dashes. You may use a new line for each port.<hr />Example: 80,443,8080,1000-2000",
      "hint_bypass": "These ports will be redirected to xray.",
      "hint_redirect": "These ports will bypass xray.",
      "hint_bypass_devices": "These devices will be redirected to xray.",
      "hint_redirect_devices": "These devices will bypass xray.",
      "hint_mac": "The MAC devices list.<hr/>By default only the online devices are shown. Click `Show all devices` to display all devices.<hr/>If you want to apply the policy to all devices, leave this field empty."
    },
    "RulesModal": {
      "modal_title": "Manage routing rules",
      "modal_title2": "Available routing rules",
      "rule_no": "rule #{0}",
      "no_rules_defined": "No rules defined",
      "add_new_rule": "Add new rule",
      "label_friendly_name": "Friendly name",
      "label_outbound_tag": "Outbound connection",
      "label_inbound_tags": "Inbound connections",
      "label_users": "Apply to Users",
      "label_domain_matcher": "Domain matcher",
      "label_network": "Network",
      "label_protocols": "Protocols",
      "label_domains": "Domains",
      "label_target_ips": "Target IP List",
      "label_target_ports": "The target port range",
      "label_source_ips": "Source IP List",
      "label_source_ports": "The source port",
      "alert_delete_rule_confirm": "Are you sure you want to delete this rule?",
      "hint_friendly_name": "A friendly name for the rule.",
      "hint_outbound_tag": "The tag of the outbound proxy. This rule will take effect when the outbound connection matches the tag.",
      "hint_inbound_tags": "An array where each item represents an inbound proxy tag. This rule will take effect when the inbound connection matches any of the tags in the array.",
      "hint_users": "Apply this rule to specific users. This rule will take effect when the source user matches any of the email.",
      "hint_domain_matcher": "The domain name matching algorithm, which uses different algorithms based on different settings. This option affects all RuleObject that do not have a separately specified matching algorithm.<ul><li>**hybrid**: Use the new domain name matching algorithm, which is faster and takes up less space. Default value.</li><li>**linear**: Use the original domain name matching algorithm.</li></ul>",
      "hint_network": "This can be **tcp**, **udp**, or **tcp,udp**. This rule will take effect when the connection method is the specified one.",
      "hint_protocols": "An array where each item represents a protocol. This rule will take effect when the protocol of the  current connection matches any of the protocols in the array. <blockquote>The `sniffing` option in the inbound proxy must be enabled to detect the protocol type used by the connection.</blockquote>",
      "hint_domains": "An array where each item is a domain match.<ul><li>Plain string: If this string matches any part of the target domain, the rule takes effect.</li><li>Regular expression: Starts with **regexp:** followed by a regular expression.</li><li>Subdomain (recommended): Starts with **domain:** followed by a domain. When this domain is the target domain or a subdomain of the target domain, the rule takes effect. For example, `domain:xray.com` matches `www.xray.com` and `xray.com`, but not `wxray.com`.</li><li>Exact match: Starts with **full:** followed by a domain. When this domain is an exact match for the target domain, the rule takes effect. For example, `full:xray.com` matches `xray.com` but not `www.xray.com`.</li><li>Predefined domain list: Starts with **geosite:** followed by a name such as `geosite:google` or `geosite:youtube`. Ensure to get latest geodata (press `update metadata` in the `routing` section).</li><li>Load domains from a file: Formatted as **ext:file:tag**, where the file is stored in the resource directory and has the same format as geosite.dat. The tag must exist in the file.</li></ul>",
      "hint_target_ips": "An array where each item represents an IP range. This rule will take effect when the target IP matches any of the IP ranges in the array.",
      "hint_target_ports": "The target port range, which can take on three forms:<ul><li>`a-b`: a and b are both positive integers less than `65536`. This range is a closed interval, and this rule will take effect when the target port falls within this range.</li><li>`a`: a is a positive integer less than `65536`. This rule will take effect when the target port is a.</li><li>A mixture of the above two forms, separated by commas, For example: `53,443,1000-2000`.</li></ul>",
      "hint_source_ips": "An array where each item represents an IP range in the format of IP, CIDR, GeoIP, or loading IP from a file. This rule will take effect when the source IP matches any of the IP ranges in the array.",
      "hint_source_ports": "The source port, which can take on three forms:<ul><li>`a-b`: a and b are both positive integers less than `65536`. This range is a closed interval, and this rule will take effect when the target port falls within this range.</li> <li>`a`: a is a positive integer less than `65536`. This rule will take effect when the target port is a.</li><li>A mixture of the above two forms, separated by commas, For example: `53,443,1000-2000`.</li></ul>"
    },
    "Inbounds": {
      "title": "Inbounds",
      "label_create_new": "Create new",
      "modal_title_inbound_settings": "Inbound settings",
      "alert_tag_exists": "Tag  already exists, please choose another one.",
      "alert_delete_confirm": "Are you sure you want to delete this inbound?",
      "alert_delete_tag_in_rules_use": "This tag ({1}) is used in the routing rules ({0}). Please remove it from the rules before deleting the inbound."
    },
    "Outbounds": {
      "title": "Outbounds",
      "label_create_new": "Create new",
      "alert_tag_exists": "Tag  already exists, please choose another one.",
      "alert_delete_confirm": "Are you sure you want to delete this outbound?",
      "alert_delete_tag_in_rules_use": "This tag ({1}) is used in the routing rules ({0}). Please remove it from the rules before deleting the outbound."
    },
    "StreamSettingsModal": {
      "title": "Transport settings",
      "modal_security_title": "Security settings",
      "modal_title": "Transport",
      "modal_desc": "Transports specify how to achieve stable data transmission. Both ends of a connection often need to specify the same transport protocol to successfully establish a connection. Like, if one end uses WebSocket, the other end must also use WebSocket, or else the connection cannot be established.",
      "label_security": "Security",
      "label_network": "Network",
      "label_tproxy": "Transparent Proxy (tproxy)",
      "hint_tproxy": "Specifies the socket options for the transport layer. The default value is `off`.",
      "hint_security": "Specifies the security settings for the transport layer. The default value is `none`.",
      "hint_network": "Specifies the network protocol. The default value is `tcp`."
    },
    "Version": {
      "tooltip_update_avialable": "a more recent update is available",
      "modal_title": "XRAYUI Version Log",
      "current_version": "Current version: {0}",
      "new_version": "A newer version is available: <strong style='color:#FFCC00'>{0}</strong>",
      "version_is_up_to_date": "Your version is up to date.",
      "open_chengelog": "open full <a target='_blank' href='https://github.com/DanielLavrushin/asuswrt-merlin-xrayui/blob/main/CHANGELOG.md'>changelog</a>",
      "update_now": "update now!",
      "dont_want_update": "Don't want to update to {0}"
    },
    "Reality": {
      "modal_title": "REALITY Settings",
      "modal_desc": "Configures REALITY. REALITY is a piece of advanced encryption technology developed in-house, with higher security than vanilla TLS, but configs of both are largely the same.",
      "label_enable_logs": "Enable logs",
      "label_dest": "Destination",
      "label_server_names": "Server names",
      "label_server_name": "Server name",
      "label_short_id": "Short ID",
      "label_short_ids": "Short IDs",
      "label_proxy_version": "Proxy version",
      "label_private_key": "Private key",
      "label_public_key": "Public key",
      "label_spider_x": "Spider X",
      "label_fingerprint": "Fingerprint",
      "hint_enable_logs": "Emits verbose logs when `true`.",
      "hint_dest": "The destination address of the server. Same schema as `dest` in `VLESS`. **Required**. same as dest in VLESS.",
      "hint_server_names": "A list of accepted server names. No support for `*` wildcards yet. **Required**.",
      "hint_server_name": "One of the server names accepted by the server.. **Required**.",
      "hint_short_id": "One of the short IDs accepted by the server.<hr>`shortId` on clients can be left blank if a blank value exists on the server.",
      "hint_short_ids": "**Required**. A list of `shortIds` accepted. Can be used to dist``inguish different clients. Specified in hex strings, with the length as multiples of `2`. Cannot be longer than `16` characters.<br />`shortId` on clients can be left blank if a blank value exists on the server.",
      "hint_proxy_version": "The version of the PROXY protocol to use. Same schema as `xver` in `VLESS`. **Optional**.",
      "hint_private_key": "Generate with `xray x25519`. **Required**.",
      "hint_public_key": "The public key that corresponds to the private key on the server. Can be obtained by `xray x25519 -i -privateKey-`. **Required**.",
      "hint_spider_x": "The bootstrapping path and query params of the spider. It's recommended to have this varied per client.",
      "hint_fingerprint": " Specifies the fingerprint of the TLS Client Hello message. When empty, fingerprint simulation will not be enabled. When enabled, Xray will simulate the TLS fingerprint through the uTLS library or have it generated randomly.<ul><li>`random`: randomly select one of the up-to-date browsers</li><li>`randomized`: generate a completely random and unique fingerprint (100% compatible with TLS 1.3 using `X25519`) </li> </ul>",
      "add_new_id": "Add new ID"
    },
    "Tls": {
      "modal_title": "TLS Settings",
      "modal_desc": "Configures vanilla TLS. The TLS encryption suite is provided by Golang, which often uses TLS 1.3, and has no support for DTLS.",
      "label_server_name": "Server name",
      "label_alpn": "ALPN",
      "label_allow_insecure": "Whether to allow insecure connections",
      "label_reject_unknown_sni": "Reject unkown SNI",
      "label_dont_use_ca": "Don't use CA",
      "label_tls_version": "TLS version",
      "label_certificate": "Certificate",
      "label_fingerprint": "Fingerprint",
      "label_pinned_peer_certificate": "Pinned Peer Certificate",
      "label_session_resumption": "Session resumption",
      "hint_server_name": "Specifies the domain of the server-side certificate, useful when connecting only via IP addresses.<br />When the target is specified by domains, like when the domain is received by `SOCKS` inbounds or detected via sniffing, the extracted domain will automatically be used as `serverName`, without any need for manual configuration.",
      "hint_alpn": "An array of strings specifying the ALPN values used in TLS handshakes. Defaults to `['h2', 'http/1.1']`.<br />Application-Layer Protocol Negotiation (ALPN) is a TLS extension that allows the application to negotiate which protocol should be performed over a secure connection in a manner that is more efficient than sending multiple requests over the same connection.",
      "hint_allow_insecure": "Whether to allow insecure connections (client-only). Defaults to `false`. <br /> When `true`, Xray will not verify the validity of the TLS certificate provided by the outbound. <blockquote>**Danger**: This should not be set to `true` in deployments for security reaons, or it can be susceptible to man-in-the-middle attacks. </blockquote>",
      "hint_reject_unknown_sni": "When `true`, the server rejects `TLS` handshakes if the SNI received does not match domains specified in the certificate. The default value is `false`.",
      "hint_dont_use_ca": "Whether to disable the CA certificates provided by the operating system. Defaults to `false`. When `true`, Xray will only use the certificates specified in certificates for TLS handshakes. When `false`, Xray will only use the CA certificates provided by the operating system for TLS handshakes.",
      "hint_tls_version": "Specifies the `minimum` and `maximum` version of the TLS protocol.",
      "hint_certificate": "Certificate",
      "hint_fingerprint": "Specifies the fingerprint of the TLS Client Hello message. When empty, fingerprint simulation will not be enabled. When enabled, Xray will simulate the TLS fingerprint through the uTLS library or have it generated randomly. ",
      "hint_pinned_peer_certificate": "SHA256 certificate fingerprints for certificate pinning. Enter one fingerprint per line (e.g., `AE243D668EC9C7F74A0DCD1AD21C6676B4EFE30C39728934B362093AF886BF77`).<br /><br />**Leaf Certificate**: Specifying a leaf certificate allows hashes within the same certificate chain to pass verification directly.<br /><br />**CA Certificate**: Specifying a CA certificate temporarily passes verification and adds the verified CA to the certificate pool. Use with `serverName` for custom self-signed CAs.<blockquote>If neither is specified, verification will fail.</blockquote>",
      "hint_session_resumption": "When `false`, the `session_ticket` extension will not be included in `ClientHello`. Oftentimes the `ClientHello` in Go programs does not have this extension enabled, so it is recommended to leave it as-is. Defaults to `false`.",
      "label_ech_config_list": "ECH Config List",
      "hint_ech_config_list": "Client-only. Configures ECHConfig to enable Encrypted Client Hello. Supports two formats:<br /><b>Fixed:</b> A base64-encoded ECHConfig string.<br /><b>DNS query:</b> A URL like <code>udp://1.1.1.1</code> or <code>https://1.1.1.1/dns-query</code> to dynamically obtain ECHConfig via HTTPS DNS records. You can also prefix a domain: <code>example.com+https://1.1.1.1/dns-query</code>.",
      "label_ech_force_query": "ECH Force Query",
      "hint_ech_force_query": "Controls the strategy when using DNS to query ECH Config.<br /><b>none:</b> Query once; if failed, retry after 5 minutes. ECH not used on failure.<br /><b>half:</b> Query once; if failed, retry on every request. ECH not used if response lacks ECH Config.<br /><b>full:</b> Forcibly requires a valid ECH Config; connection fails without it. Recommended if ECH is mandatory.",
      "label_ech_server_keys": "ECH Server Keys",
      "hint_ech_server_keys": "Server-only. Used to enable Encrypted Client Hello on the server. Generate with <code>xray tls ech --serverName example.com</code>. After configuring, the server still accepts normal non-ECH connections.",
      "label_ech_server_name": "ECH Server Name",
      "hint_ech_server_name": "The domain name used to generate ECH keys. Enter your server's domain before clicking Regenerate above.",
      "hint_ech_server_name_desc": "required for ECH key generation"
    },
    "DownloadSettings": {
      "modal_title": "Download Settings",
      "modal_desc": "Configure separate download stream settings for uplink/downlink separation. This allows directing upstream and downstream traffic through different paths/connections for enhanced anti-censorship.",
      "label_address": "Download Server Address",
      "label_port": "Download Server Port",
      "label_security": "Security Protocol",
      "label_xhttp": "XHTTP Settings",
      "label_sockopt": "Socket Options",
      "label_uplink_downlink": "Uplink/Downlink Separation",
      "label_path": "Request Path",
      "label_host": "CDN Host / Virtual Host",
      "label_mode": "Transfer Mode",
      "hint_address": "Separate domain/IP for downstream. Can differ from upload server.",
      "hint_port": "Port for downstream connection",
      "hint_security": "Choose security layer for downstream (required)",
      "hint_xhttp": "Configure xhttp parameters for downstream",
      "hint_sockopt": "Advanced socket options for downstream",
      "hint_uplink_downlink": "Enable separate download stream for enhanced anti-censorship",
      "hint_path": "must match upload path",
      "security_title": "Download Security Settings",
      "xhttp_title": "Download XHTTP Settings",
      "sockopt_title": "Download Socket Options"
    },
    "Kcp": {
      "label_mtu": "MTU",
      "label_tti": "TTI",
      "label_uplink_capacity": "Uplink capacity",
      "label_downlink_capacity": "Downlink capacity",
      "label_congestion": "Congestion control",
      "label_read_buffer": "Read buffer size",
      "label_write_buffer": "Write buffer size",
      "label_seed": "Seed",
      "label_header": "Packet header obfuscation",
      "hint_mtu": "Maximum transmission unit. It indicates the maxium bytes that an UDP packet can carry.<hr>Recommended value is between `576` and `1460`. The default value is `1350`",
      "hint_tti": "Transmission time interval, measured in milliseconds (ms), determines how often `mKCP` sends data.<hr>Please choose a value between `10` and `100`. The default value is `50`",
      "hint_uplink_capacity": "Uplink capacity refers to the maximum bandwidth used by the host to send data, measured in MB/s (note: `Byte`, not `bit`). It can be set to `0`, indicating a very small bandwidth. The default value is `5`",
      "hint_downlink_capacity": "Downlink capacity refers to the `maximum` bandwidth used by the host to receive data, measured in MB/s (note: `Byte`, not `bit`).<hr>It can be set to `0`, indicating a very small bandwidth. The default value is `20`",
      "hint_congestion": "Whether or not to enable congestion control. When congestion control is enabled, Xray will detect network quality. It will send less packets when packet loss is severe, or more packets when network is not fully filled. The default value is `false`",
      "hint_read_buffer": "The read buffer size for a single connection, measured in MB. The default value is `2`",
      "hint_write_buffer": "The write buffer size for a single connection, measured in MB. The default value is `2`",
      "hint_header": "Configuration for packet header obfuscation.",
      "hint_seed": "An optional obfuscation seed is used to obfuscate traffic data using the `AES-128-GCM` algorithm.<hr>The client and server need to use the same seed. This obfuscation mechanism cannot ensure the security of the content, but it may be able to resist some blocking."
    },
    "Grpc": {
      "label_service_name": "Service name",
      "label_health_check": "Health check",
      "label_health_check_timeout": "Health check timeout",
      "label_permit_without_stream": "Permit without stream",
      "label_initial_windows_size": "The initial window size of the h2 stream",
      "hint_service_name": "A string that specifies the service name, similar to the path in `HTTP/2`. The client will use this name for communication, and the server will verify whether the service name matches.",
      "hint_health_check": "The health check is performed when no data transmission occurs for a certain period of time, measured in `seconds`. If this value is set to less than `10`, `10` will be used as the `minimum` value.",
      "hint_health_check_timeout": "The timeout for the health check, measured in seconds. If the health check is not completed within this time period, it is considered to have failed. The default value is `20`",
      "hint_permit_without_stream": "If set to `true` allows health checks to be performed when there are no sub-connections. The default value is `false`.",
      "hint_initial_windows_size": "The initial window size of the `h2` stream. When the value is less than or equal to `0`, this feature does not ntake effect.<hr>When the value is greater than `65535`, the Dynamic Window mechanism will be disabled. The default value is `0`, which means it is not effective."
    },
    "HttpUpgrade": {
      "label_accept_proxy_protocol": "Accept PROXY protocol",
      "label_path": "The HTTP path",
      "label_host": "Host",
      "hint_accept_proxy_protocol": "Indicates whether to accept the `PROXY` protocol. <br /> The `PROXY` protocol is used to transmit the real source IP and port of connections. If you are not familiar with this, leave it alone. <br /> Commonplace reverse proxy software solutions (like `HAProxy` and `NGINX`) can be configured to have source IPs and ports sent with `PROXY` protocol. Same goes to `VLESS` fallbacks xver. <br /> When true, after the underlying `TCP` connection is established, the downstream must first send the source IPs and ports in `PROXY` protocol v1 or v2, or the connection will be terminated.",
      "hint_path": "HTTP path used by the HTTPUpgrade connection. Defaults to `/`. <br /> If the path property include an ed query field (e.g. `/mypath?ed=2560`), `early data` will be used to decrease latency, with the value defining the threshold of the first packet's size. If the size of the first packet exceeds the defined value, `early data` will not be applied. The recommended value is `2560`.",
      "hint_host": "HTTP Host sent by the `HTTPUpgrade` connection. `Empty` by default. If this value is empty on the server, the host header sent by clients will not be validated. <hr /> If the `Host` header has been defined on the server in any way, the server will validate if the `Host` header matches. <hr /> The current priority of the Host header sent by clients: `host` > `headers` > `address`"
    },
    "HeadersMapping": {
      "label_headers_row": "Customized HTTP headers",
      "pl_header_key": "Header key",
      "pl_header_value": "Header value"
    },
    "Tcp": {
      "label_accept_proxy_protocol": "Accept PROXY protocol",
      "hint_accept_proxy_protocol": "Indicates whether to accept the `PROXY` protocol. <br /> The `PROXY` protocol is used to transmit the real source IP and port of connections. If you are not familiar with this, leave it alone. <br /> Commonplace reverse proxy software solutions (like `HAProxy` and `NGINX`) can be configured to have source IPs and ports sent with `PROXY` protocol. Same goes to `VLESS` fallbacks xver. <br /> When true, after the underlying `TCP` connection is established, the downstream must first send the source IPs and ports in `PROXY` protocol v1 or v2, or the connection will be terminated."
    },
    "SniffingModal": {
      "modal_title": "Traffic sniffing",
      "modal_desc": "Traffic sniffing is mainly used in transparent proxies. It can detect the protocol type used by the connection and then forward the connection to the corresponding outbound proxy.",
      "label_settings": "Sniffing Settings",
      "label_enabled": "Sniffing",
      "label_metadata_only": "Metadata only",
      "label_dest_override": "Destination override",
      "label_route_only": "Route only",
      "label_domains_excluded": "Excluded domains",
      "hint_settings": "Sniffing Settings",
      "hint_enabled": "Whether to enable traffic sniffing.",
      "hint_metadata_only": "When enabled, only use the connection's metadata to sniff the target address. In this case, sniffer other than `fakedns` (including `fakedns+others`) cannot be activated. <hr/> If metadata-only is `disabled`, the client must send data before the proxy server actually establishes the connection. This behavior is incompatible with protocols that require the server to initiate the first message, such as the SMTP protocol.",
      "hint_dest_override": "When the traffic is of a specified type, reset the destination of the current connection to the target address included in the list.<hr/> `['fakedns+others']` is equivalent to `['http', 'tls', 'quic', 'fakedns']`, and when the IP address is in the FakeIP range but no domain records are hit, `http`, `tls`, and `quic` will be used for matching. This option is only effective when metadataOnly is set to false.",
      "hint_route_only": "Use the sniffed domain name for routing only, and keep the target address as the IP address. The default value is `false`.This option requires `destOverride` to be enabled. <blockquote> When it is possible to ensure that the proxied connection can obtain correct DNS resolution, by using `routeOnly` and enabling `destOverride`, and setting the routing matching strategy `domainStrategy` to `AsIs`, it is possible to achieve domain and IP separation without DNS resolution throughout the process. The IP used when encountering an IP rule match is the original IP of the domain. </blockquote>",
      "hint_domains_excluded": "A list of domain names. If the traffic sniffing result matches a domain name in this list, the target address will not be reset. <blockquote> **Warning** Currently, `domainsExcluded` does not support domain name matching in the routing sense. This option may change in the future and cross-version compatibility is not guaranteed. </blockquote>",
      "modal_domains_title": "Manage excluded domains",
      "modal_domains_desc": "If the traffic sniffing result matches a domain name in this list, the target address will not be reset."
    },
    "GeodatModal": {
      "modal_title": "Geodata Files Manager",
      "modal_desc": "Here you can create, edit and manage your own geosite/geoip data files.",
      "loading": "Loading...",
      "recompile_all": "recompile all",
      "compile": "compile",
      "alert_delete_confirm": "Are you sure you want to delete this file?",
      "alert_empty_content": "Well... Nice try, but you need to write something into the content field.",
      "option_create_new_file": "Create new file",
      "label_select_file": "Select a file",
      "label_tag": "Tag",
      "label_content": "Content",
      "hit_recompile_all": "usefull when you edit your tag files directly on your router and only want to recompile the xrayui geodata.",
      "hit_compile": "save a tag file content and compile into the xrayui geodata format.",
      "hint_tag": "The tag of the geodata file. This tag will be used in the routing rules.",
      "hint_content": "The content of the geodata file. <hr/> An array where each item is a domain match.<ul><li>Plain string: If this string matches any part of the target domain, the rule takes effect.</li><li>Regular expression: Starts with **regexp:** followed by a regular expression.</li><li>Subdomain (recommended): Starts with **domain:** followed by a domain. When this domain is the target domain or a subdomain of the target domain, the rule takes effect. For example, `domain:xray.com` matches `www.xray.com` and `xray.com`, but not `wxray.com`.</li><li>Exact match: Starts with **full:** followed by a domain. When this domain is an exact match for the target domain, the rule takes effect. For example, `full:xray.com` matches `xray.com` but not `www.xray.com`.</li><li>Predefined domain list: Starts with **geosite:** followed by a name such as `geosite:google` or `geosite:youtube`. Ensure to get latest geodata (press `update metadata` in the `routing` section).</li><li>Load domains from a file: Formatted as **ext:file:tag**, where the file is stored in the resource directory and has the same format as geosite.dat. The tag must exist in the file.</li></ul>"
    },
    "AllocateModal": {
      "modal_title": "The port allocation strategy",
      "label_settings": "Settings",
      "label_strategy": "Strategy",
      "label_refresh": "Refresh",
      "label_concurrency": "Concurrency",
      "hint_strategy": "The port allocation strategy.<ul><li>`always`: all specified ports in port will be allocated, and Xray will listen on these ports.</li><li>`random`: ports will be randomly selected from the port range every refresh minutes, andconcurrency ports will be listened on.</li></ul>",
      "hint_refresh": "The interval for refreshing randomly allocated ports in minutes. The minimum value is `2`, and it is recommended to set to `5`. This property is only effective when `strategy` is set to `random`.",
      "hint_concurrency": "The number of randomly allocated ports. The `minimum` value is `1`, and the `maximum` value is one-third of the port range. It is recommended to set to `3`."
    },
    "InboundCommon": {
      "label_tag": "Tag",
      "label_listen": "The listening address",
      "label_port": "Listening Port",
      "label_port_allocate": "port allocation",
      "hint_tag": "The identifier of this inbound connection, used to locate this connection in other configurations.",
      "hint_listen": "The listening address, either an IP address or a Unix domain socket. The default value is `0.0.0.0`, which means accepting connections on all network interfaces.<hr/>An available system IP address can be specified.",
      "hint_port": "Listening port for inbound connections. Xray listens for inbound connections on that port."
    },
    "DocodemoDoorInbound": {
      "modal_title": "Dokodemo-Door",
      "modal_desc": "Dokodemo door (Anywhere Door) can listen to a local port and forward all incoming data on this port to a specified server's port, achieving the effect of port mapping.",
      "label_address": "Destination address",
      "label_port": "Destination port",
      "label_network": "Network",
      "label_follow_redirect": "Follow redirect",
      "hint_address": "The address to forward the traffic to. It can be an IP address like `1.2.3.4` or a domain name like `xray.com`.<hr/>When `followRedirect` is set to `true`, address can be empty.",
      "hint_port": "The specified port on the destination address to forward the traffic to. It is a numeric value and is a **required** parameter.",
      "hint_network": "The supported network protocol type. For example, when specified as `tcp`, it will only receive TCP traffic. The default value is `tcp`.",
      "hint_follow_redirect": "When set to `true`, dokodemo-door will recognize data forwarded by `iptables` and forward it to the corresponding destination address.<hr/>Refer to the `tproxy` setting in the `Transport Configuration`"
    },
    "TunInbound": {
      "modal_title": "TUN",
      "modal_desc": "TUN interface support bridges the gap between network layer 3 and layer 7, introducing raw network input. This functionality is targeted to assist applications/devices that don't have proxy support, making it possible to run Xray proxy on network edge devices (routers) to route raw network traffic. <blockquote>**Important**: This is an advanced feature intended for network professionals. Improper configuration may result in network loops or connectivity issues. The TUN interface requires OS-level routing configuration to function properly.</blockquote>",
      "label_name": "Interface name",
      "label_mtu": "MTU",
      "label_gso": "Enable GSO",
      "label_address": "IP addresses",
      "label_routes": "Routes",
      "hint_name": "The name of the TUN interface to create (e.g., `xray0`, `tun0`). This interface will be created by Xray and must be configured at the OS level with routing rules.",
      "hint_mtu": "Maximum Transmission Unit for the TUN interface. Typically `1500` for standard networks, but may need to be lower (e.g., `1492`, `1420`) depending on your network configuration and encapsulation overhead.",
      "hint_gso": "Enable Generic Segmentation Offload. Generally should be disabled (`false`) for forwarded traffic on router devices as it may not provide performance benefits and can add complexity.",
      "hint_address": "IP addresses to assign to the TUN interface. Enter one address per line in CIDR notation (e.g., `192.168.10.1/24` for IPv4 or `fd00::1/64` for IPv6).<hr/>These addresses are optional and can be managed by OS-level network configuration instead.",
      "hint_address_placeholder": "Example: 192.168.10.1/24",
      "hint_routes": "Routes to add for the TUN interface. Enter one route per line in CIDR notation (e.g., `0.0.0.0/0` for all IPv4 traffic, `10.0.0.0/8` for specific networks).<hr/><blockquote>**Warning**: Routing `0.0.0.0/0` through the TUN interface without proper upstream routing can cause network loops. Ensure static routes to Xray upstreams exist, or use separate routing tables.</blockquote>",
      "hint_routes_placeholder": "Example: 10.0.0.0/8"
    },
    "ShadowsocksInbound": {
      "modal_title": "Shadowsocks",
      "modal_desc": "The Shadowsocks protocol is compatible with most other implementations of Shadowsocks. The server supports TCP and UDP packet forwarding, with an option to selectively disable UDP.",
      "label_network": "Network",
      "label_method": "Encryption Method",
      "label_password": "Password",
      "label_email": "Email",
      "hint_network": "The supported network protocol type. For example, when specified as `tcp`, it will only handle TCP traffic. The default value is `tcp`.",
      "hint_method": "The encryption method to use for this inbound. For Shadowsocks 2022 protocols (2022-blake3-*), use `openssl rand -base64 32` to generate a secure password. Recommended methods: 2022-blake3-aes-128-gcm, 2022-blake3-aes-256-gcm, 2022-blake3-chacha20-poly1305",
      "hint_password": "The password parameter can be specified for the server at all, but also in the ClientObject being dedicated to the given user. Server-level password is not guaranteed to override the client-specific one.",
      "hint_email": "The user's email, used to differentiate traffic from different users for logs or statistics."
    },
    "OutboundCommon": {
      "label_tag": "Tag",
      "label_send_through": "Send through",
      "hint_tag": "The identifier of this outbound connection, used to locate this connection in other configurations. <blockquote>**Danger**: When it is not empty, its value must be unique among all tags.</blockquote>",
      "hint_send_through": "The IP address used to send data. It is effective when the host has multiple IP addresses, and the default value is `0.0.0.0`.<hr/> It is allowed to fill in the IPv6 CIDR block (such as `114:514:1919:810::/64`), and Xray will use the random IP address in the address block to initiate external connections. Network access, routing tables, and kernel parameters need to be configured correctly to allow Xray to bind to any IP within the address block.<hr/> For networks that use ndp to access, it is not recommended to set a subnet smaller than `/120`, otherwise it may cause NDP flood and a series of problems such as the router neighbor cache being filled up.",
      "label_subscription_url": "Subscription URL",
      "hint_subscription_url": "Enter the subscription URL that fetches updates for this outbound configuration.<hr/>Updates are applied on every service restart.<hr/>While a URL is set, certain settings are disabled because they are managed by the subscription.",
      "label_subscription_type": "Available Subscription Configuration",
      "hint_subscription_type": "The type of the subscription configuration. <ul> <li>`xray`: Xray subscription configuration</li> <li>`clash`: Clash subscription configuration</li> </ul><hr/>This setting is only effective when the `subscriptionUrl` is not set.",
      "label_auto_fallback": "Auto-fallback pool",
      "hint_auto_fallback": "Enable to include this outbound in the auto-fallback pool. When the active endpoint becomes unreachable, it will be automatically rotated to the next alive endpoint from the subscription pool.<hr/>Requires the global auto-fallback option to be enabled in General Settings.",
      "warn_auto_fallback_requires_observatory": "Requires Xray Connection Check to be enabled in General Settings."
    },
    "FreedomOutbound": {
      "modal_title": "Freedom",
      "modal_desc": "Freedom is an outbound protocol that can be used to send (normal) TCP or UDP data to any network.",
      "label_domain_strategy": "Domain strategy",
      "label_redirect": "Redirect address",
      "label_proxy_protocol": "PROXY protocol",
      "label_fragment": "Fragment packet method",
      "label_fragment_length": "Fragment length",
      "label_fragment_interval": "Fragment interval",
      "label_udp_noise": "UDP noise",
      "modal_udp_noise_title": "Manage noise entries",
      "modal_udp_noise_entry_title": "Noise Entry",
      "label_udp_noise_type": "Type",
      "label_udp_noise_packet": "Packet",
      "label_udp_noise_delay": "Delay",
      "hint_udp_noise_type": "Three types are supported. <ul> <li>`rand` - generates a random byte</li> <li>`str` - uses a user input string</li> <li>`base64` - uses a user input base64 encoded string</li> </ul>",
      "hint_udp_noise_packet": "If type is set to <ul> <li>`rand` - takes a range `50-100` or a single value `50`</li> <li>`str` - takes a string</li> <li>`base64` - takes a `base64` encoded string</li> </ul>",
      "hint_udp_noise_delay": "The delay before sending real data (ms). can be a string range like `10-20` or a single integer If not specified, the default value is `0`.",
      "hint_domain_strategy": "When the destination address is a domain name, configure the corresponding value for Freedom's behavior: <ul> <li>`AsIs`: Freedom resolves the domain name using the system DNS server and connects to it.</li> <li>`UseIP, UseIPv4, and UseIPv6`: Xray resolves the domain name using the built-in DNS server and connects to it.</li> </ul> <blockquote> **Note**: When using the `UseIP` mode and the `sendThrough` field is specified in the outbound connection configuration, `Freedom` will automatically determine the required IP type, `IPv4` or `IPv6`, based on the value of `sendThrough`. </blockquote> <blockquote> **Note**: When using the `UseIPv4` or `UseIPv6` mode, `Freedom` will only use the corresponding `IPv4` or `IPv6` address. If `sendThrough` specifies a mismatched local address, the connection will fail. </blockquote>",
      "hint_redirect": "Freedom will force all data to be sent to the specified address (instead of the address specified in the inbound). It is a string value, for example: `127.0.0.1:80`, `:1234`. When the address is not specified, such as `:443`, `Freedom` will not modify the original destination address. When the port is `0`, such as `xray.com:0`, `Freedom` will not modify the original port.",
      "hint_proxy_protocol": "The value of `proxyProtocol` represents the PROXY Protocol version. default value is `0`.",
      "hint_fragment": "A key-value map used to control TCP fragmentation, under some circumstances it can cheat the censor system, like bypass a SNI blacklist. <ul> <li>`1-3` - segmentation at the TCP layer, applying to the beginning 1 to 3 data writes by the client.</li> <li>`tlshello` - TLS client hello packet fragmentation.</li> </ul>",
      "hint_fragment_length": "length to make the cut",
      "hint_fragment_interval": "time between fragments (ms)",
      "hint_udp_noise": "An array used to control UDP noise, under some circumstances it can bypass some udp based protocol restrictions. xray will loop through this array and send each noise packet one by one."
    },
    "BlackholeOutbound": {
      "modal_title": "Blackhole",
      "modal_desc": "Blackhole is an outbound data protocol that blocks all outbound data. When used in conjunction with routing configurations, it can be used to block access to certain websites.",
      "label_response": "Response",
      "hint_response": "Configures the response data for the blackhole.<hr/>After receiving the data to be forwarded, the blackhole will send the specified response data and then close the connection. The data to be forwarded will be discarded. If this field is not specified, the blackhole will simply close the connection<ul> <li>`none`: The `blackhole` will simply close the connection.</li> <li>`http`: The `blackhole` will send a simple `HTTP 403` packet as the response and then close the connection.</li> </ul>"
    },
    "VlessOutbound": {
      "modal_title": "VLESS",
      "modal_desc": "VLESS is a stateless lightweight transport protocol, which is divided into inbound and outbound parts, and can be used as a bridge between Xray clients and servers. Unlike VMess, VLESS does not rely on system time, and the authentication method is also UUID.",
      "label_address": "Server address",
      "label_port": "Server port",
      "hint_address": "Server address, pointing to the server, supporting domain names, `IPv4` and `IPv6`.",
      "hint_port": "Server port, usually the same as the port listened by the server."
    },
    "VmessOutbound": {
      "modal_title": "VMess",
      "modal_desc": "VMess is an encrypted transport protocol commonly used as a bridge between Xray clients and servers.",
      "label_address": "Server address",
      "label_port": "Server port",
      "hint_address": "Server address, pointing to the server, supporting domain names, `IPv4` and `IPv6`.",
      "hint_port": "Server port, usually the same as the port listened by the server."
    },
    "HysteriaOutbound": {
      "modal_title": "Hysteria",
      "modal_desc": "Hysteria is a feature-packed proxy & relay tool optimized for lossy, unstable connections (e.g. satellite networks, congested public Wi-Fi, connecting to foreign servers from China). It uses a custom protocol based on QUIC.",
      "label_version": "Hysteria version",
      "label_address": "Server address",
      "label_port": "Server port",
      "hint_version": "Select Hysteria protocol version (1 or 2). Version 2 is recommended for new deployments.",
      "hint_address": "Server address, pointing to the Hysteria server, supporting domain names, `IPv4` and `IPv6`.",
      "hint_port": "Server port, usually the same as the port listened by the Hysteria server."
    },
    "CertificatesModal": {
      "modal_title": "Manage TLS Certificate",
      "label_ocsp_stapling": "OCSP stapling",
      "label_one_time_loading": "One-time loading",
      "label_usage": "Usage",
      "label_build_chain": "Build chain",
      "label_certificate_file": "Path to .crt file",
      "label_certificate_content": "Certificate content",
      "label_key_file": "Path to .key file",
      "label_key_content": "Key content",
      "hint_ocsp_stapling": "OCSP stapling update interval in seconds for certificate hot reload. Default value is `3600`, i.e. one  hour.",
      "hint_one_time_loading": "Load only once. When set to `true`, it will disable certificate hot reload and OCSP stapling feature. <blockquote> **Warning**: When set to `true`, `OCSP` stapling will be `disabled`. </blockquote>",
      "hint_usage": "Certificate usage, default value is `encipherment`.<ul><li>`encipherment`: The certificate is used for TLS authentication and encryption.</li><li>`verify`: The certificate is used to verify the remote TLS certificate. When using this option, the current certificate must be a CA certificate.</li><li>`issue`: The certificate is used to issue other certificates. When using this option, the current certificate must be a CA certificate.</li></ul>",
      "hint_build_chain": "Only valid when usage is issue. When set to `true`, the CA certificate will be appended to leaf certificate as chain during issuing certificates. <blockquote> Root certificates should not be embedded in the certificate chain. This option is only applicable when the signing CA certificate is an intermediate certificate. </blockquote>",
      "hint_certificate_file": "Path to the certificate file. When the certificate content is empty, the content will be read from the file.",
      "hint_certificate_content": "Certificate content. When the certificate file path is empty, the content will be read from the field.",
      "hint_key_file": "Path to the key file. When the key content is empty, the content will be read from the file.",
      "hint_key_content": "Key content. When the key file path is empty, the content will be read from the field."
    },
    "DnsServersModal": {
      "modal_desc": "A list of DNS servers, which can be either DNS addresses (in string form) or DnsServerObjects (advanced options).",
      "no_hosts_defined": "No hosts defined",
      "advanced": "advanced",
      "server": "Server",
      "list": "List of defined servers",
      "modal_server_title": "Advanced options",
      "modal_server_title2": "Server Settings",
      "label_address": "Address",
      "label_port": "Port",
      "label_domains": "Domains",
      "label_client_ip": "Client IP",
      "label_expected_ips": "Expected IPs",
      "label_skip_fallback": "Skip fallback",
      "hint_client_ip": "Used to notify the server of the specified IP location during DNS queries. Cannot be a private address.",
      "hint_domains": "A list of domain names. The domain names in this list will be queried using this server first. The format of domain names is the same as in routing configuration.",
      "hint_port": "The port number of the DNS server, such as 53. If not specified, the default is 53. This item is not applicable when using DOH, DOHL, or DOQL modes, and non-standard ports should be specified in the URL.",
      "hint_expected_ips": "A list of IP ranges in the same format as in routing configuration. When this item is configured, Xray DNS will verify the returned IP addresses and only return addresses that are included in the expectIPs list. If this item is not configured, the IP address will be returned as is.",
      "hint_skip_fallback": "true means to skip this server when performing DNS fallback queries, and the default is false, which means not to skip.",
      "label_domain_rules": "Associated rules",
      "modal_rules_list": "Associated rules",
      "hint_domains_disabled": "The domains for this server are managed based on the associated rules.",
      "hint_ips_disabled": "The IPs for this server are managed based on the associated rules.",
      "hint_domain_rules": "It is possible to link specific rules to this server. When a rule is linked, its domains will be used."
    },
    "ProcessUptime": {
      "label": "X-RAY Core uptime",
      "formatted_time": "{0}d {1}h {2}m {3}s"
    },
    "XrayCoreVersionModal": {
      "modal_title": "X-RAY Core Update",
      "modal_desc": "Select a version to switch to:",
      "switch": "Switch to this version"
    },
    "ReverseProxy": {
      "title": "Reverse Proxy",
      "hint_title": "A reverse proxy forwards traffic from a server to a client, which is known as reverse traffic forwarding.",
      "label_bridges": "Bridges",
      "label_portals": "Portals",
      "hint_bridges": "An array in which each item represents a bridge. The configuration of each bridge is a `BridgeObject`.",
      "hint_portals": "An array in which each item represents a portal. The configuration of each portal is a `PortalObject`."
    },
    "ReverseItemsModal": {
      "modal_title": "Reverse Proxy Items",
      "modal_title2": "List"
    },
    "Profiles": {
      "manager": "Profiles Manager",
      "modal_title": "Manage Profiles",
      "hint": "Select a configuration profile from the list below. This list is automatically populated with all JSON files in the `/opt/etc/xray` directory. Once you choose a profile.<br/>You can also manage the list by adding or removing configuration files as needed."
    },
    "ClientsOnline": {
      "title": "Clients Online",
      "label_client": "Client",
      "label_ip": "Ip",
      "message_logs": "To check online users, xray logging must be enabled. Would you like to enable it?",
      "enable_logs": "Enable logs",
      "online": "online",
      "noone_is_online": "No one is online"
    },
    "Backup": {
      "manager": "Manage Backups",
      "backup": "backup",
      "clear": "clear",
      "hint": "Backup xray/xrayui configuration files.",
      "clear_confirm": "Are you sure you want to delete {0}?",
      "clear_all_confirm": "Are you sure you want to clear all the backups?",
      "restore_confirm": "Are you sure  you want to restore this backup?\nWarning: This will overwrite the current configuration.\n\nIt is recommended to create a backup before restoring.",
      "download": "download",
      "restore": "restore"
    },
    "Logs": {
      "title": "Xray Logs",
      "display": "view logs",
      "type": "Log type to load"
    },
    "FakeDns": {
      "label": "Fake DNS Settings",
      "hint": "FakeDNS is used to obtain target domain names by forging DNS, which can reduce the delay in DNS queries and work with transparent proxies to obtain target domain names. <blockquote>**Warning:** FakeDNS may contaminate the local DNS and cause `network unreachable` after Xray is closed.</blockquote>",
      "label_ip_pool": "IP Pool",
      "hint_ip_pool": "FakeDNS will use the IP block specified by this option to allocate addresses.",
      "label_pool_size": "Pool Size",
      "hint_pool_size": "Specifies the maximum number of domain name-IP mappings stored by `FakeDNS`. When the number of mappings exceeds this value, mappings will be eliminated according to the LRU rule. The default is `65535`.",
      "fakedns": "fakedns"
    },
    "NetworkHysteria": {
      "title": "Hysteria Transport Settings",
      "label_version": "Hysteria Version",
      "hint_version": "Select Hysteria protocol version (1 or 2). Version 2 is recommended for new deployments with improved performance and features.",
      "label_auth": "Authentication String",
      "hint_auth": "Authentication string for Hysteria connection. This must match the server configuration.",
      "label_congestion": "Congestion Control",
      "hint_congestion": "Congestion control algorithm. <ul><li>`brutal`: Optimized for maximum throughput</li><li>`bbr`: Bottleneck Bandwidth and Round-trip propagation time</li></ul>",
      "label_up": "Upload Bandwidth",
      "hint_up": "Maximum upload bandwidth (e.g., `100mbps`, `1gbps`). Used by the congestion control algorithm.",
      "label_down": "Download Bandwidth",
      "hint_down": "Maximum download bandwidth (e.g., `100mbps`, `1gbps`). Used by the congestion control algorithm.",
      "udphop_title": "UDP Hop Configuration",
      "label_udphop_enabled": "Enable UDP Hop",
      "hint_udphop_enabled": "UDP Hop allows bouncing UDP packets across multiple ports to avoid detection and blocking.",
      "label_udphop_port": "Port Range",
      "hint_udphop_port": "Port range for UDP hopping (e.g., `20000-50000`). Packets will hop between ports in this range.",
      "label_udphop_interval": "Hop Interval",
      "hint_udphop_interval": "Time interval in seconds between port hops. Default is 30 seconds.",
      "salamander_title": "Salamander Obfuscation",
      "label_salamander_enabled": "Enable Salamander",
      "hint_salamander_enabled": "Salamander is a UDP masking/obfuscation protocol that disguises Hysteria traffic characteristics to avoid detection.",
      "label_salamander_password": "Obfuscation Password",
      "hint_salamander_password": "Password for Salamander obfuscation. This must match the server configuration."
    },
    "SockOpt": {
      "label": "Transparent Proxy Settings",
      "hint": "Transparent Proxy Settings allow you to configure various options for the transparent proxy feature.",
      "label_tproxy_enable": "Enable Transparent Proxy",
      "label_tproxy_interface": "Interface",
      "label_tproxy_domain_strategy": "Domain Strategy",
      "label_tproxy_mark": "Mark",
      "label_tcpmptcp": "Enable Multipath TCP",
      "label_dealer_proxy": "Dealer Proxy",
      "label_tcp_no_delay": "TCP No Delay",
      "hint_tproxy_enable": "Enable or disable transparent proxying.",
      "hint_tproxy_interface": "Specifies the name of the bound outbound network interface. supported by Linux MacOS iOS. MacOS iOS Requires `Xray-core v1.8.6` or higher.",
      "hint_tproxy_domain_strategy": "The domain strategy to use for transparent proxying.",
      "hint_tproxy_mark": "The mark to use for transparent proxying.",
      "hint_tcp_no_delay": "Enable or disable TCP No Delay, Default value false, recommended to be enabled with `tcpMptcp`: true.",
      "hint_tcpmptcp": "Enable or disable Multipath TCP.",
      "hint_dealer_proxy": "An identifier for an outbound proxy. When the value is not empty, the specified outbound will be used to establish the connection. This option can be used to support chain forwarding of underlying transport protocols."
    },
    "Rtls": {
      "manager": "Reality TLS Scanner",
      "info": "The Reality TLS Scanner helps you discover public TLS endpoints in a subnet and highlights the ones closest to your target IP (e.g., your VPS). It visualizes findings on a `radar` and lists them in a sortable table so you can quickly select suitable hosts for REALITY-based configurations.",
      "modal_title": "Reality TLS Scanner",
      "hint": "Scan the selected subnet to discover domains closest to the target IP.",
      "scan": "scan",
      "scan_start": "Start Scan",
      "scan_stop": "Stop Scan",
      "ip_label": "IP Address",
      "cidr_label": "CIDR",
      "timeout_label": "Timeout",
      "threads_label": "Threads",
      "ip_hint": "Enter the target IP address.",
      "cidr_hint": "Select the subnet (CIDR) to scan.",
      "timeout_hint": "Set the timeout for each probe (in seconds).",
      "threads_hint": "Set the number of concurrent threads.<blockquote>**Warning**: A high thread count may make your router unresponsive. Higher thread counts produce faster results but may also cause instability.</blockquote>",
      "result_ip": "IP Address",
      "result_domain": "Domain",
      "result_issuer": "Issuer",
      "result_country": "Country",
      "result_proximity": "Proximity",
      "search": "Search",
      "issuer_filter": "Issuer Filter",
      "country_filter": "Country Filter",
      "sort_by_proximity": "Sort by Proximity",
      "sort_by_ip": "Sort by IP",
      "sort_by_domain": "Sort by Domain",
      "sort_asc": "Sort Ascending",
      "found": "Found",
      "issuers": "Issuers",
      "countries": "Countries",
      "closest": "Closest Domain",
      "scan_progress": "Scanning is in progress..."
    },
    "Xhttp": {
      "modal_anti_detection": "Anti-Detection Settings",
      "hint_anti_detection": "Configure padding obfuscation, HTTP method, and session/sequence placement to bypass CDN-based traffic filtering.",
      "modal_performance": "Performance Tuning",
      "hint_performance": "Configure POST sizes, intervals, buffering, and uplink data placement for optimal throughput.",
      "modal_xmux": "XMUX Settings",
      "hint_xmux": "Configure XMUX connection multiplexing parameters for HTTP/2 stream management.",
      "label_xPaddingObfsMode": "Enable padding obfuscation",
      "hint_xPaddingObfsMode": "Enables the X-Padding anti-detection mechanism. When active, Xray customizes how padding is placed in requests to defeat traffic fingerprinting by CDNs.",
      "label_xPaddingPlacement": "Padding placement",
      "hint_xPaddingPlacement": "Where the padding is placed in the HTTP request. <ul><li><code>queryInHeader</code> (default) - in the URL query string within the header</li><li><code>cookie</code> - in a Cookie header</li><li><code>header</code> - in a custom HTTP header</li><li><code>query</code> - in the URL query string</li></ul>",
      "label_xPaddingMethod": "Padding method",
      "hint_xPaddingMethod": "The algorithm for generating padding content.<ul><li><code>repeat-x</code> (default) - repeats X/Z character pattern</li><li><code>tokenish</code> - generates token-like random strings that look like cache busters</li></ul>",
      "label_xPaddingKey": "Padding query key",
      "hint_xPaddingKey": "The query parameter or cookie name used for the padding value. Default: <code>x_padding</code>.",
      "label_xPaddingHeader": "Padding HTTP header",
      "hint_xPaddingHeader": "The HTTP header name carrying the padding value. Default: <code>X-Padding</code>.",
      "label_uplinkHTTPMethod": "Uplink HTTP method",
      "hint_uplinkHTTPMethod": "The HTTP method used for uplink requests. Some CDNs block POST but allow PUT or PATCH. Default: <code>POST</code>.",
      "label_uplinkDataPlacement": "Uplink data placement",
      "hint_uplinkDataPlacement": "Where the uplink payload data is placed.<ul><li><code>body</code> (default) - in the request body</li><li><code>cookie</code> - in a Cookie header (packet-up mode only)</li><li><code>header</code> - in a custom HTTP header (packet-up mode only)</li></ul>",
      "label_uplinkDataKey": "Uplink data key",
      "hint_uplinkDataKey": "The key name for the uplink data when placement is cookie or header. Auto-generated if empty.",
      "label_uplinkChunkSize": "Uplink chunk size (bytes)",
      "hint_uplinkChunkSize": "Maximum size in bytes of each uplink data chunk. Minimum 64 bytes. Auto-calculated based on placement if not set (3KB for cookie, 4KB for header).",
      "label_sessionPlacement": "Session ID placement",
      "hint_sessionPlacement": "Where the session identifier is placed in requests.<ul><li><code>path</code> (default) - in the URL path</li><li><code>cookie</code> - in a Cookie header</li><li><code>header</code> - in a custom HTTP header</li><li><code>query</code> - in the URL query string</li></ul>",
      "label_sessionKey": "Session key name",
      "hint_sessionKey": "The key name for the session ID. Auto-generated if empty. Ignored when placement is <code>path</code>.",
      "label_seqPlacement": "Sequence number placement",
      "hint_seqPlacement": "Where the request sequence number is placed.<ul><li><code>path</code> (default) - in the URL path</li><li><code>cookie</code> - in a Cookie header</li><li><code>header</code> - in a custom HTTP header</li><li><code>query</code> - in the URL query string</li></ul>",
      "label_seqKey": "Sequence key name",
      "hint_seqKey": "The key name for the sequence number. Auto-generated if empty. Ignored when placement is <code>path</code>."
    },
    "SniLogs": {
      "title": "SNI Logs",
      "display": "display",
      "clear_logs": "clear logs",
      "no_logs": "No SNI logs available",
      "total": "total",
      "unique_sni": "unique SNI",
      "export_csv": "export CSV",
      "raw": "raw data",
      "tab_by_device": "By Device",
      "tab_by_domain": "By Domain",
      "tab_live": "Live Stream",
      "hits": "hits",
      "last_seen": "last seen",
      "protocols": "protocols",
      "devices": "devices",
      "domain": "domain",
      "domains_count": "domains",
      "add_to_rule": "+ Rule",
      "add_selected_to_rule": "add selected to rule",
      "create_new_rule": "New rule",
      "rule_name": "Rule name",
      "outbound": "Outbound",
      "added_to_rule": "Added to \"{0}\"",
      "no_rules_available": "No routing rules defined. Create a new one.",
      "top_domain": "top",
      "most_active": "most active"
    }
  }
}