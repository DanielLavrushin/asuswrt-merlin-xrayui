{
  "labels": {
    "import": "імпорт",
    "connect": "підключити",
    "reconnect": "перепідключити",
    "start": "запустити",
    "restart": "перезапустити",
    "stop": "зупинити",
    "show_config": "показати конфіг",
    "manage": "керувати",
    "add": "додати",
    "delete": "видалити",
    "server": "сервер",
    "client": "клієнт",
    "transport": "транспорт",
    "sniffing": "перехоплення",
    "apply": "застосувати",
    "close": "закрити",
    "cancel": "скасувати",
    "accept": "прийняти",
    "save": "зберегти",
    "edit": "редагувати",
    "redorder": "перемістити вгору",
    "renew": "оновити",
    "regenerate": "перегенерувати",
    "enabled": "увімкнено",
    "disabled": "вимкнено",
    "items": "елем: {0}",
    "xrayui_desc": "Ця сторінка управління інтерфейсом забезпечує простий спосіб керувати та контролювати конфігурацію X-ray Core та його стан."
  },
  "com": {
    "ClientStatus": {
      "configuration": "Конфігурація",
      "connection_status": "Статус з'єднання",
      "general_options": "Загальні налаштування",
      "xray_connecting": "Перевіряється з'єднання...",
      "xray_connected": "XRAY підключено",
      "xray_stopped": "XRAY зупинено",
      "xray_running": "Сервіс XRAY працює"
    },
    "ServerStatus": {
      "configuration": "Конфігурація",
      "connection_status": "Статус з'єднання",
      "general_options": "Загальні налаштування",
      "xray_connecting": "Перевіряється з'єднання...",
      "xray_connected": "XRAY підключено",
      "xray_stopped": "XRAY зупинено",
      "xray_running": "Сервіс XRAY працює"
    },
    "GeneralOptionsModal": {
      "modal_title": "Загальні налаштування XRAYUI",
      "check_xray_connection": "Перевірити з'єднання з сервером XRAY",
      "start_xray_on_reboot": "Запустити XRAY при перезавантаженні роутера",
      "modalConnectTitle": "Перевірка з'єднання XRAY",
      "modalConnectCheckDescription": "<p>Ця опція перевіряє, чи працює з'єднання, надсилаючи запит до <a href=\"https://ip-api.com/\" target=\"_blank\">ip-api.com</a> через вихідний проксі під час запуску.</p><p>XRAYUI додасть системне правило до правил маршрутизації та створить вхідний SOCKS-проксі для цієї перевірки. Ці системні налаштування позначені тегом <code>sys</code> і залишаться прихованими в інтерфейсі.</p>",
      "logs_header": "Логи",
      "label_logs_enable_access": "Включити логи доступу",
      "label_logs_enable_error": "Включити логи помилок",
      "label_logs_enable_dns": "Включити DNS-логи",
      "label_logs_level": "Рівень логування",
      "label_gh_proxy": "Використовувати проксі GitHub",
      "hint_gh_proxy": "Використовувати проксі-сервер GitHub для завантаження файлів з GitHub (оновлення Xray, файли геоданих тощо), якщо GitHub заблоковано у вашому регіоні.",
      "geodad_header": "GeoIP/GeoSite метадані",
      "label_geoip_url": "URL GeoIP",
      "label_geosite_url": "URL GeoSite",
      "wellknown_geodata": "Використовувати загальновідомі геодані",
      "label_logs_enable_dnsmasqlog": "Увімкнути логи dnsmasq",
      "hint_logs_enable_dnsmasqlog": "Увімкнення цієї опції дозволить логам показувати доменні імена замість IP-адрес.",
      "label_logs_max_size": "Максимальний розмір логу",
      "hint_logs_max_size": "Максимальний розмір файлу логу. Коли розмір перевищує це значення, лог буде автоматично ротовано.",
      "label_logs_dor": "Очищати логи при перезапуску Xray",
      "label_geosite_autoupdate": "Автооновлення файлів геоданих",
      "label_skip_test": "Пропустити перевірку XRAY",
      "hint_skip_test": "Якщо ви не хочете перевіряти файл конфігурації XRAY, ви можете пропустити цей крок. Проте рекомендується залишити цю опцію увімкненою, щоб переконатися, що конфігураційний файл є коректним.<hr/>Ця перевірка може споживати ресурси, тому її варто вимкнути, якщо ви використовуєте малопотужний маршрутизатор.<hr/>Якщо ви вимкнете цю опцію, перевірка конфігурації буде пропущена, і конфігураційний файл застосується напряму."
    },
    "ImportConfig": {
      "import_config_file": "Імпортувати файл конфігурації"
    },
    "ImportConfigModal": {
      "modal_title": "Імпортувати конфігурацію",
      "modal_desc": "Тут ви можете імпортувати конфігурацію з QR-коду або URL протоколу.",
      "label_qr_code": "QR-код",
      "label_proxy_uri": "URI вихідного проксі",
      "label_complete_setup": "Я хочу повну конфігурацію!",
      "label_unblock": "Розблокувати",
      "label_dont_break": "Не заважати роботі моїх мережевих пристроїв",
      "hint_qr_code": "Спробуйте зробити скріншот вашого QR-коду, і xrayui спробує його прочитати.",
      "hint_proxy_uri": "Ви можете вставити сюди URL протоколу. Зазвичай вони починаються з `vless://` або `vmess://`.",
      "hint_complete_setup": "Якщо ви оберете цю опцію, xrayui перезапише вашу поточну конфігурацію найвідповіднішою конфігурацією за замовчуванням для імпортованого протоколу.<hr />Створиться стандартне правило маршрутизації для перевірки вихідного проксі-з'єднання. Після імпорту та застосування конфігурації ви можете спробувати відкрити `https://ip-api.com/`. Ви повинні побачити IP-адресу сервера, до якого ви підключені.<hr />Після цього рекомендується налаштувати власні правила маршрутизації трафіку.",
      "hint_unblock": "Виберіть сервіси, які ви хочете розблокувати. Це автоматично створить `правило маршрутизації`, яке направить їхній трафік через проксі.<hr />Рекомендується обирати лише ті сервіси, які заблоковані у вашому регіоні. Ви зможете додавати, оновлювати або видаляти ці правила пізніше в розділі `Маршрутизація`.",
      "hint_dont_break": "Позначте це поле, якщо у вашій мережі роутера є IoT-пристрої, такі як `Smart TV`, `Xbox`, `PlayStation` чи інші пристрої, на які ви не хочете впливати за допомогою X-RAY.<hr />Ця опція обмежує перенаправлення трафіку через X-RAY через ваш роутер, що знижує ризик відключення цих пристроїв. Пізніше ви зможете налаштувати цю опцію в розділі `Маршрутизація` (`Політика обходу/переадресації портів`).<hr />Якщо у вас немає IoT-пристроїв, краще залишити цю опцію неактивною.",
      "label_import_type": "Тип імпорту",
      "opt_qr": "QR-код",
      "opt_url": "URL",
      "opt_json": "JSON",
      "opt_file": "Файл",
      "label_proxy_json": "Імпорт JSON",
      "label_proxy_file": "Імпорт файлу",
      "hint_proxy_json": "Ви можете вставити вміст JSON-файлу сюди. XRAYUI змінить конфігурацію, щоб забезпечити сумісність із маршрутизатором.",
      "hint_proxy_file": "Виберіть JSON-файл, який ви хочете імпортувати.<hr/> Використовуйте цю опцію лише якщо ви повторно завантажуєте конфігурацію, яка вже працювала, і ви впевнені, що вона підходить для вашого маршрутизатора. <hr/> Якщо ви хочете забезпечити сумісність з маршрутизатором, будь ласка, скористайтеся опцією `Імпорт JSON`."
    },
    "ConfigModal": {
      "modal_title": "Показати файл конфігурації XRAY",
      "hide_sensetive_data": "сховати конфіденційні дані",
      "open_raw": "відкрити сирий",
      "copy_to_clipboard": "скопіювати в буфер",
      "alert_copy_ok_hiddendata": "Конфігурацію скопійовано в буфер. Конфіденційні дані сховано. Однак, будь ласка, перевірте конфігурацію перед поширенням.",
      "alert_copy_ok_nohiddendata": "Конфігурацію скопійовано в буфер. Попередження: конфіденційні дані видно. Будьте обережні при поширенні."
    },
    "Dns": {
      "title": "DNS",
      "label_tag": "Тег",
      "label_hosts": "Хости",
      "label_servers": "Сервери",
      "label_client_ip": "IP клієнта",
      "label_query_strategy": "Стратегія запиту",
      "label_disable_cache": "Вимкнути кеш",
      "label_disable_fallback": "Вимкнути резерв",
      "label_fallback_if_match": "Резерв при збігу",
      "hint_title": "Вбудований модуль DNS в Xray має дві основні цілі:<ul><li>Під час фази маршрутизації він перетворює доменні імена на IP-адреси та розподіляє трафік на основі результатів розв’язання доменних імен і значення domainStrategy у модулі конфігурації маршрутизації. Вбудований DNS-сервер використовується для DNS-запитів лише тоді, коли встановлено одне з наступних значень:<ul><li><strong>IPIfNonMatch</strong>: Коли запитується доменне ім’я, спочатку здійснюється спроба зіставлення його з записами доменів у конфігурації маршрутизації. Якщо збіг не знайдено, вбудований DNS-сервер виконує DNS-запит для цього доменного імені, а отримана IP-адреса використовується для повторного зіставлення за IP-маршрутизацією.</li><li><strong>IPOnDemand</strong>: Якщо доменне ім’я відповідає будь-якому правилу, заснованому на IP, воно негайно перетворюється на IP-адресу для зіставлення.</li></ul></li><li>Він визначає цільову адресу для з’єднання.</li><li>У налаштуваннях freedom outbound, якщо **domainStrategy** встановлено на **UseIP**, запит через вихідний проксі спочатку перетворює доменне ім’я на IP-адресу за допомогою вбудованого сервера перед встановленням з’єднання.</li><li>У налаштуваннях sockopt, якщо **domainStrategy** встановлено на **UseIP**, системні з’єднання, ініційовані через вихідний проксі, спочатку перетворюються на IP-адресу за допомогою вбудованого сервера перед встановленням з’єднання.</li></ul>",
      "hint_tag": "Трафік, згенерований вбудованим **DNS** (за винятком режимів localhost, fakedns, **TCPL**, **DOHL** та **DOQL**), може бути зіставлений з `inboundTag` у маршрутизації за допомогою цього ідентифікатора.",
      "hint_hosts": "Список статичних `IP-адрес`, що складається з ряду доменів та адрес. Адреса може бути як IP, так і доменним ім’ям. При розв’язанні доменного імені, якщо воно співпадає з елементом цього списку:<ul><li>Якщо адреса елемента є IP, результат розв’язання буде цією IP.</li><li>Якщо адреса елемента є доменним ім’ям, це доменне ім’я буде використано для розв’язання замість початкового.</li><li>Якщо в адресі вказано декілька IP та доменних імен, повернеться лише перше доменне ім’я, а решта будуть ігноровані.</li></ul>",
      "hint_servers": "Список DNS-серверів. Адреса може бути як IP, так і доменним ім’ям. При розв’язанні доменного імені буде використано цей DNS-сервер.",
      "hint_client_ip": "Використовується для повідомлення сервера про вказане розташування IP під час DNS-запитів. Не може бути приватною адресою.",
      "hint_query_strategy": "`UseIPv4` виконує запити лише до записів A; `UseIPv6` – лише до записів AAAA. Значення за замовчуванням — `UseIP`, що виконує запити до записів A та AAAA.",
      "hint_disable_cache": "`true` вимикає кешування DNS, за замовчуванням `false`, тобто кешування не вимикається.",
      "hint_disable_fallback": "`true` вимикає резервні DNS-запити, за замовчуванням `false`, тобто резервні запити не вимикаються.",
      "hint_fallback_if_match": "`true` вимикає резервні DNS-запити, коли спрацьовує список співставлення доменів DNS-сервера, за замовчуванням `false`, тобто резервні запити не вимикаються."
    },
    "Routing": {
      "title": "Маршрутизація",
      "label_domain_strategy": "Стратегія домену",
      "label_domain_matcher": "Алгоритм зіставлення доменів",
      "label_rules": "Правила",
      "label_geodat_metadata": "Метадані GeoIP/GeoSite",
      "label_policies": "Політика обходу/переадресації",
      "manage_local_files": "керувати локальними файлами",
      "update_community_files": "оновити файли спільноти",
      "hint_title": "Модуль маршрутизації може направляти вхідні дані через різні вихідні з’єднання згідно з різними правилами для реалізації проксирування за запитом. <p>Звичайний сценарій використання — розділення внутрішнього та іноземного трафіку. Xray може використовувати свої внутрішні механізми для визначення трафіку з різних регіонів, а потім направляти його до різних вихідних проксі.</p>",
      "hint_domain_strategy": "Стратегія розв’язання доменних імен, яка використовує різні підходи залежно від налаштувань.<ul><li>**AsIs**: Використовувати лише доменне ім’я для вибору маршруту. Значення за замовчуванням.</li><li>**IPIfNonMatch**: Якщо доменне ім’я не відповідає жодному правилу, перетворити його на IP-адресу (запис A або AAAA) та повторити зіставлення<ul><li>Якщо домен має кілька записів A, буде спроба зіставити всі записи, поки одне з них не відповідає правилу.</li><li>Отримана IP використовується лише для вибору маршруту, а початкове доменне ім’я залишається в пакетах.</li></ul></li><li>**IPOnDemand**: Якщо під час зіставлення зустрічаються правила, засновані на IP, доменне ім’я негайно перетворюється на IP-адресу для зіставлення.</li></ul>",
      "hint_domain_matcher": "Алгоритм зіставлення доменних імен, який використовує різні методи залежно від налаштувань. Ця опція впливає на всі об’єкти правил, для яких не задано окремий алгоритм зіставлення.<ul><li>**hybrid**: Використовувати новий алгоритм зіставлення доменних імен, який швидший і займає менше місця. Значення за замовчуванням.</li><li>**linear**: Використовувати оригінальний алгоритм зіставлення доменних імен.</li></ul>",
      "hint_policies": "Налаштуйте політики маршрутизації для окремих пристроїв (bypass або redirect) для Xray. Ви можете вказати MAC-адреси, режими (bypass або redirect) та порти для тонкого налаштування обробки трафіку.",
      "hint_rules": "Масив, що відповідає списку правил. Для кожного з’єднання маршрутизація перевірятиме ці правила зверху до низу. Коли знайдеться перше ефективне правило, з’єднання буде направлено до вихідного тегу або тегу балансувальника, вказаного в правилі. <blockquote>Якщо жодне правило не відповідає, трафік за замовчуванням направляється через перше вихідне з’єднання.</blockquote>",
      "hint_geodat_metadata": "Оновіть файли метаданих GeoIP та GeoSite. Ця операція може зайняти деякий час, будь ласка, зачекайте.",
      "hint_ports_policy": "За замовчуванням використовується режим `redirect`, що означає, що трафік на всіх портах перенаправляється на вхідний порт xray. Вкажіть додаткові порти, через які має проходити або обходитися Xray. <ul><li><strong>redirect</strong>: Трафік на всіх портах перенаправляється на вхідний порт. Ви визначаєте порти, які НЕ повинні перенаправлятися до Xray.</li><li><strong>bypass</strong>: Трафік на всіх портах обходить Xray. Ви визначаєте порти, які мають бути явно направлені до Xray.</li></ul>"
    },
    "PolicyModal": {
      "modal_title2": "Список політик",
      "rule_no": "політика #{0}",
      "no_rules_defined": "Політики не визначено",
      "label_friendly_name": "Дружня назва",
      "label_mac": "Пристрої",
      "label_show_all": "Показати всі пристрої",
      "modal_title": "Політика обходу/перенаправлення",
      "modal_desc": "За замовчуванням використовується режим <strong>redirect</strong>, що означає, що трафік на всіх портах перенаправляється на вхідний порт xray. Вкажіть додаткові порти, через які має маршрутизуватися трафік або, навпаки, обходитися xray. <ul> <li> <strong>redirect</strong>: Трафік на всіх портах перенаправляється на вхідний порт. Ви визначаєте порти, які НЕ повинні перенаправлятися до xray. </li> <li> <strong>bypass</strong>: Трафік на всіх портах обходить xray. Ви визначаєте порти, які мають бути явно перенаправлені до xray. </li> </ul>",
      "label_mode": "Режим",
      "label_tcp_ports": "TCP порти",
      "label_udp_ports": "UDP порти",
      "label_wellknown_ports": "Застосувати загальновідомі порти сервісів",
      "hint_friendly_name": "Дружня назва для правила.",
      "hint_mode": "Режим політики. <ul> <li> <strong>redirect</strong>: Трафік на всіх портах перенаправляється на вхідний порт. Ви визначаєте порти, які НЕ повинні перенаправлятися до xray. </li> <li> <strong>bypass</strong>: Трафік на всіх портах обходить xray. Ви визначаєте порти, які мають бути явно перенаправлені до xray. </li> </ul>",
      "hint_tcp_ports": "Допустимі символи: лише цифри, коми та дефіси. Можна використовувати новий рядок для кожного порту.<hr />Приклад: 80,443,8080,1000-2000",
      "hint_udp_ports": "Допустимі символи: лише цифри, коми та дефіси. Можна використовувати новий рядок для кожного порту.<hr />Приклад: 80,443,8080,1000-2000",
      "hint_bypass": "Ці порти будуть перенаправлені до xray.",
      "hint_redirect": "Ці порти обходять xray.",
      "hint_bypass_devices": "Ці пристрої будуть перенаправлені до xray.",
      "hint_redirect_devices": "Ці пристрої обходять xray.",
      "hint_mac": "Список MAC-адрес пристроїв.<hr/>За замовчуванням відображаються лише онлайн-пристрої. Натисніть «Показати всі пристрої», щоб переглянути всі.<hr/>Якщо ви бажаєте застосувати політику до всіх пристроїв, залиште це поле порожнім."
    },
    "RulesModal": {
      "modal_title": "Керувати правилами маршрутизації",
      "modal_title2": "Доступні правила маршрутизації",
      "rule_no": "правило #{0}",
      "no_rules_defined": "Правила не задано",
      "add_new_rule": "Додати нове правило",
      "label_friendly_name": "Зручна назва",
      "label_outbound_tag": "Вихідне з’єднання",
      "label_inbound_tags": "Вхідні з’єднання",
      "label_users": "Застосувати до користувачів",
      "label_domain_matcher": "Алгоритм зіставлення доменів",
      "label_network": "Мережа",
      "label_protocols": "Протоколи",
      "label_domains": "Домени",
      "label_target_ips": "Список цільових IP",
      "label_target_ports": "Діапазон цільових портів",
      "label_source_ips": "Список вихідних IP",
      "label_source_ports": "Вихідний порт",
      "alert_delete_rule_confirm": "Ви впевнені, що хочете видалити це правило?",
      "hint_friendly_name": "Зручна назва для правила.",
      "hint_outbound_tag": "Тег вихідного проксі. Це правило спрацює, коли вихідне з’єднання відповідає цьому тегу.",
      "hint_inbound_tags": "Масив, де кожен елемент представляє тег вхідного проксі. Це правило спрацює, коли вхідне з’єднання відповідає будь-якому з тегів у масиві.",
      "hint_users": "Застосувати це правило до конкретних користувачів. Це правило спрацює, коли електронна адреса джерела відповідає будь-якій з вказаних.",
      "hint_domain_matcher": "Алгоритм зіставлення доменних імен, який використовує різні методи залежно від налаштувань. Ця опція впливає на всі об’єкти правил, для яких не задано окремий алгоритм зіставлення.<ul><li>**hybrid**: Використовувати новий алгоритм зіставлення доменних імен, який швидший і займає менше місця. Значення за замовчуванням.</li><li>**linear**: Використовувати оригінальний алгоритм зіставлення доменних імен.</li></ul>",
      "hint_network": "Це може бути **tcp**, **udp** або **tcp,udp**. Це правило спрацює, коли метод з’єднання відповідає вказаному.",
      "hint_protocols": "Масив, де кожен елемент представляє протокол. Це правило спрацює, коли протокол поточного з’єднання відповідає будь-якому з протоколів у масиві. <blockquote>Опція `sniffing` у вхідному проксі повинна бути увімкнена для визначення типу протоколу, що використовується в з’єднанні.</blockquote>",
      "hint_domains": "Масив, де кожен елемент є співставленням домену.<ul><li>Проста стрічка: Якщо ця стрічка співпадає з будь-якою частиною цільового домену, правило спрацює.</li><li>Регулярний вираз: Починається з **regexp:**, за яким слідує регулярний вираз.</li><li>Піддомен (рекомендується): Починається з **domain:**, за яким слідує домен. Якщо цей домен є цільовим або його піддоменом, правило спрацює. Наприклад, `domain:xray.com` співпадає з `www.xray.com` та `xray.com`, але не з `wxray.com`.</li><li>Точне співставлення: Починається з **full:**, за яким слідує домен. Якщо цей домен точно співпадає з цільовим, правило спрацює. Наприклад, `full:xray.com` співпадає з `xray.com`, але не з `www.xray.com`.</li><li>Попередньо визначений список доменів: Починається з **geosite:**, за яким слідує ім’я, наприклад, `geosite:google` або `geosite:youtube`. Переконайтеся, що у вас актуальні геодані (натисніть `update metadata` у розділі `маршрутизації`).</li><li>Завантаження доменів з файлу: Форматується як **ext:file:tag**, де файл зберігається у директорії ресурсів і має той же формат, що й geosite.dat. Тег має існувати у файлі.</li></ul>",
      "hint_target_ips": "Масив, де кожен елемент представляє діапазон IP. Це правило спрацює, коли цільова IP відповідає будь-якому з діапазонів у масиві.",
      "hint_target_ports": "Діапазон цільових портів, який може бути заданий трьома способами:<ul><li>`a-b`: a та b – позитивні цілі числа, менші за `65536`. Це закритий інтервал, і правило спрацює, коли цільовий порт знаходиться в цьому діапазоні.</li><li>`a`: a – позитивне ціле число, менше за `65536`. Правило спрацює, коли цільовий порт дорівнює a.</li><li>Суміш попередніх двох форматів, розділених комами, наприклад: `53,443,1000-2000`.</li></ul>",
      "hint_source_ips": "Масив, де кожен елемент представляє діапазон IP у форматі IP, CIDR, GeoIP або завантаження IP з файлу. Це правило спрацює, коли вихідна IP відповідає будь-якому з діапазонів у масиві.",
      "hint_source_ports": "Вихідний порт, який може бути заданий трьома способами:<ul><li>`a-b`: a та b – позитивні цілі числа, менші за `65536`. Це закритий інтервал, і правило спрацює, коли вихідний порт знаходиться в цьому діапазоні.</li><li>`a`: a – позитивне ціле число, менше за `65536`. Правило спрацює, коли вихідний порт дорівнює a.</li><li>Суміш попередніх двох форматів, розділених комами, наприклад: `53,443,1000-2000`.</li></ul>"
    },
    "Inbounds": {
      "title": "Вхідні",
      "label_create_new": "Створити нове",
      "modal_title_inbound_settings": "Налаштування вхідних з'єднань",
      "alert_tag_exists": "Такий тег вже існує, будь ласка, оберіть інший.",
      "alert_delete_confirm": "Ви впевнені, що хочете видалити це вхідне з'єднання?"
    },
    "Outbounds": {
      "title": "Вихідні",
      "label_create_new": "Створити нове",
      "alert_tag_exists": "Такий тег вже існує, будь ласка, оберіть інший.",
      "alert_delete_confirm": "Ви впевнені, що хочете видалити це вихідне з'єднання?"
    },
    "StreamSettingsModal": {
      "title": "Налаштування транспорту",
      "modal_security_title": "Налаштування безпеки",
      "modal_title": "Транспорт",
      "modal_desc": "Транспорти визначають, як забезпечити стабільну передачу даних. Обидва кінці з’єднання часто повинні використовувати один і той же транспортний протокол для успішного встановлення з’єднання. Наприклад, якщо один кінець використовує WebSocket, інший також має використовувати WebSocket, інакше з’єднання не буде встановлено.",
      "label_security": "Безпека",
      "label_network": "Мережа",
      "label_tproxy": "Прозорий проксі (tproxy)",
      "hint_tproxy": "Задає параметри сокета для транспортного рівня. Значення за замовчуванням – `off`.",
      "hint_security": "Задає налаштування безпеки для транспортного рівня. Значення за замовчуванням – `none`.",
      "hint_network": "Задає мережевий протокол. Значення за замовчуванням – `tcp`."
    },
    "Version": {
      "tooltip_update_avialable": "доступне новіше оновлення",
      "modal_title": "Журнал версій XRAYUI",
      "current_version": "Поточна версія: {0}",
      "new_version": "Доступна новіша версія: <strong style='color:#FFCC00'>{0}</strong>",
      "version_is_up_to_date": "Ваша версія актуальна.",
      "open_chengelog": "відкрити повний <a target='_blank' href='https://github.com/DanielLavrushin/asuswrt-merlin-xrayui/blob/main/CHANGELOG.md'>журнал змін</a>",
      "update_now": "оновити зараз!",
      "dont_want_update": "Не оновлювати до {0}"
    },
    "Reality": {
      "modal_title": "Налаштування REALITY",
      "modal_desc": "Налаштовує REALITY. REALITY — це сучасна технологія шифрування, розроблена всередині компанії, що забезпечує вищий рівень безпеки, ніж стандартний TLS, проте їх конфігурації здебільшого однакові.",
      "label_enable_logs": "Увімкнути логи",
      "label_dest": "Ціль",
      "label_server_names": "Імена серверів",
      "label_server_name": "Ім'я сервера",
      "label_short_id": "Короткий ID",
      "label_short_ids": "Короткі ID",
      "label_proxy_version": "Версія проксі",
      "label_private_key": "Приватний ключ",
      "label_public_key": "Публічний ключ",
      "label_spider_x": "Spider X",
      "label_fingerprint": "Відбиток",
      "hint_enable_logs": "Виводить докладні логи, коли встановлено `true`.",
      "hint_dest": "Адреса цілі сервера. Відповідає схемі `dest` у `VLESS`. **Обов'язково**.",
      "hint_server_names": "Список прийнятних імен серверів. Підстановочні символи (`*`) наразі не підтримуються. **Обов'язково**.",
      "hint_server_name": "Одне з імен серверів, прийнятих сервером. **Обов'язково**.",
      "hint_short_id": "Один із коротких ID, прийнятих сервером.<hr>Поле `shortId` для клієнтів може залишатися порожнім, якщо на сервері встановлено порожнє значення.",
      "hint_short_ids": "**Обов'язково**. Список прийнятих `shortIds`. Може використовуватися для розрізнення різних клієнтів. Задається як шістнадцяткові рядки, довжина яких має бути кратною `2` і не може перевищувати `16` символів.<br>Поле `shortId` для клієнтів може залишатися порожнім, якщо на сервері встановлено порожнє значення.",
      "hint_proxy_version": "Версія PROXY-протоколу, що використовується. Відповідає схемі `xver` у `VLESS`. **Необов'язково**.",
      "hint_private_key": "Згенерувати за допомогою `xray x25519`. **Обов'язково**.",
      "hint_public_key": "Публічний ключ, що відповідає приватному ключу на сервері. Можна отримати за допомогою `xray x25519 -i -privateKey-`. **Обов'язково**.",
      "hint_spider_x": "Шлях ініціалізації та параметри запиту для Spider X. Рекомендується, щоб вони відрізнялися для кожного клієнта.",
      "hint_fingerprint": "Задає відбиток TLS Client Hello повідомлення. Якщо порожнє, симуляція відбитку не буде увімкнена. При увімкненні Xray симулюватиме TLS-відбиток за допомогою бібліотеки uTLS або згенерує його випадковим чином.<ul><li>`random`: випадковим чином обирає один із сучасних браузерів</li><li>`randomized`: генерує повністю випадковий та унікальний відбиток (100% сумісний з TLS 1.3 за використанням `X25519`)</li></ul>",
      "add_new_id": "Додати новий ID"
    },
    "Tls": {
      "modal_title": "Налаштування TLS",
      "modal_desc": "Налаштовує стандартний TLS. TLS-шифрувальний пакет надається Golang, який часто використовує TLS 1.3 і не підтримує DTLS.",
      "label_server_name": "Ім'я сервера",
      "label_alpn": "ALPN",
      "label_allow_insecure": "Чи дозволяти небезпечні з'єднання",
      "label_reject_unknown_sni": "Відхилити невідомий SNI",
      "label_dont_use_ca": "Не використовувати CA",
      "label_tls_version": "Версія TLS",
      "label_certificate": "Сертифікат",
      "label_fingerprint": "Відбиток",
      "label_session_resumption": "Відновлення сесії",
      "hint_server_name": "Визначає домен серверного сертифіката, що корисно при підключенні лише за IP-адресами.<br>Якщо ціль задана доменами, наприклад, коли домен надходить через SOCKS-вхід або визначається за допомогою перехоплення, вилучений домен автоматично використовується як `serverName` без потреби у ручному налаштуванні.",
      "hint_alpn": "Масив рядків, що вказує ALPN-значення, використовувані під час TLS-рукопотиску. За замовчуванням – `['h2', 'http/1.1']`.<br>Протокол переговорів прикладного рівня (ALPN) є розширенням TLS, яке дозволяє застосунку домовитись про те, який протокол буде використовуватись через захищене з'єднання більш ефективно, ніж при надсиланні декількох запитів через одне й те саме з'єднання.",
      "hint_allow_insecure": "Чи дозволяти небезпечні з'єднання (тільки для клієнта). За замовчуванням – `false`. <br>Якщо встановлено `true`, Xray не перевірятиме дійсність TLS-сертифіката, наданого вихідним з'єднанням. <blockquote><strong>Небезпечно</strong>: Це не слід встановлювати в робочих розгортаннях через ризик атак типу «людина посередині».</blockquote>",
      "hint_reject_unknown_sni": "Якщо встановлено `true`, сервер відхиляє TLS-рукопотискання, якщо отриманий SNI не відповідає доменам, зазначеним у сертифікаті. За замовчуванням – `false`.",
      "hint_dont_use_ca": "Чи відключати CA-сертифікати, що надаються операційною системою. За замовчуванням – `false`. Якщо встановлено `true`, Xray використовуватиме лише сертифікати, зазначені у конфігурації для TLS-рукопотиску. Якщо `false`, Xray використовуватиме лише CA-сертифікати, надані операційною системою.",
      "hint_tls_version": "Визначає мінімальну та максимальну версію TLS-протоколу.",
      "hint_certificate": "Сертифікат",
      "hint_fingerprint": "Задає відбиток повідомлення TLS Client Hello. Якщо порожнє, симуляція відбитку не буде увімкнена. При увімкненні Xray симулюватиме TLS-відбиток за допомогою бібліотеки uTLS або генеруватиме його випадковим чином.",
      "hint_session_resumption": "Якщо `false`, розширення `session_ticket` не буде включено до `ClientHello`. Часто у Go-програмах це розширення не увімкнене, тому рекомендується залишити його без змін. За замовчуванням – `false`."
    },
    "Kcp": {
      "label_mtu": "MTU",
      "label_tti": "TTI",
      "label_uplink_capacity": "Пропускна здатність вихідного каналу",
      "label_downlink_capacity": "Пропускна здатність вхідного каналу",
      "label_congestion": "Контроль заторів",
      "label_read_buffer": "Розмір буфера читання",
      "label_write_buffer": "Розмір буфера запису",
      "label_seed": "Seed",
      "label_header": "Обфускація заголовка пакета",
      "hint_mtu": "Максимальна одиниця передачі. Вона вказує максимальну кількість байтів, які може переносити UDP-пакет.<hr>Рекомендоване значення від `576` до `1460`. Значення за замовчуванням – `1350`",
      "hint_tti": "Інтервал передачі, вимірюється в мілісекундах (ms), визначає, як часто `mKCP` надсилає дані.<hr>Будь ласка, оберіть значення від `10` до `100`. Значення за замовчуванням – `50`",
      "hint_uplink_capacity": "Пропускна здатність вихідного каналу відноситься до максимальної смуги пропускання, яку використовує хост для надсилання даних, вимірюється в МБ/с (примітка: `Байт`, а не `біт`). Її можна встановити в `0`, що означає дуже малу пропускну здатність. Значення за замовчуванням – `5`",
      "hint_downlink_capacity": "Пропускна здатність вхідного каналу відноситься до максимальної смуги пропускання, яку використовує хост для прийому даних, вимірюється в МБ/с (примітка: `Байт`, а не `біт`).<hr>Її можна встановити в `0`, що означає дуже малу пропускну здатність. Значення за замовчуванням – `20`",
      "hint_congestion": "Чи увімкнути контроль заторів. Коли контроль заторів увімкнено, Xray визначає якість мережі, надсилаючи менше пакетів при значних втратних пакетах або більше, коли мережа не заповнена повністю. Значення за замовчуванням – `false`",
      "hint_read_buffer": "Розмір буфера читання для одного з'єднання, вимірюється в МБ. Значення за замовчуванням – `2`",
      "hint_write_buffer": "Розмір буфера запису для одного з'єднання, вимірюється в МБ. Значення за замовчуванням – `2`",
      "hint_header": "Обфускація заголовка пакета",
      "hint_seed": "Опціональний seed для обфускації використовується для обфускації даних трафіку за допомогою алгоритму `AES-128-GCM`.<hr>Клієнт і сервер повинні використовувати один і той же seed. Цей механізм обфускації не гарантує безпеку вмісту, але може допомогти протидіяти деякому блокуванню."
    },
    "Grpc": {
      "label_service_name": "Назва сервісу",
      "label_health_check": "Перевірка стану",
      "label_health_check_timeout": "Тайм-аут перевірки стану",
      "label_permit_without_stream": "Дозволити без потоку",
      "label_initial_windows_size": "Початковий розмір вікна h2 потоку",
      "hint_service_name": "Рядок, що задає назву сервісу, подібно до шляху в `HTTP/2`. Клієнт використовуватиме цю назву для зв'язку, а сервер перевірятиме, чи збігається назва сервісу.",
      "hint_health_check": "Перевірка стану виконується, коли протягом певного часу (в секундах) не відбувається передача даних. Якщо це значення менше `10`, буде використано `10` як мінімальне.",
      "hint_health_check_timeout": "Тайм-аут перевірки стану, вимірюється в секундах. Якщо перевірка не завершується протягом цього періоду, вона вважається невдалою. Значення за замовчуванням – `20`",
      "hint_permit_without_stream": "Якщо встановлено `true`, дозволяє виконувати перевірку стану, коли немає підз'єднань. Значення за замовчуванням – `false`.",
      "hint_initial_windows_size": "Початковий розмір вікна `h2` потоку. Якщо значення менше або дорівнює `0`, ця функція не буде діяти.<hr>Якщо значення більше `65535`, механізм динамічного вікна буде вимкнено. Значення за замовчуванням – `0`, тобто не використовується."
    },
    "HttpUpgrade": {
      "label_accept_proxy_protocol": "Приймати PROXY-протокол",
      "label_path": "HTTP-шлях",
      "label_host": "Хост",
      "hint_accept_proxy_protocol": "Вказує, чи приймати `PROXY`-протокол. <br /> `PROXY`-протокол використовується для передачі реальної IP-адреси та порту з'єднання. Якщо ви не знайомі з цим, залиште без змін. <br /> Загальновживані рішення для реверсивного проксі (такі як `HAProxy` та `NGINX`) можуть бути налаштовані для відправлення вихідних IP-адрес та портів за допомогою `PROXY`-протоколу. Те саме стосується `VLESS` fallback xver. <br /> Коли встановлено `true`, після встановлення базового TCP-з'єднання клієнт повинен спочатку відправити вихідні IP-адреси та порти за допомогою `PROXY`-протоколу версії 1 або 2, інакше з'єднання буде розірване.",
      "hint_path": "HTTP-шлях, що використовується у з'єднанні HTTPUpgrade. За замовчуванням – `/`. <br /> Якщо властивість шляху містить поле запиту (наприклад, `/mypath?ed=2560`), для зменшення затримки буде використано `ранні дані`, значення яких визначає поріг розміру першого пакету. Якщо розмір першого пакету перевищує встановлене значення, `ранні дані` не будуть застосовані. Рекомендоване значення – `2560`.",
      "hint_host": "HTTP-хост, відправлений з'єднанням HTTPUpgrade. За замовчуванням – порожній. Якщо це значення порожнє на сервері, заголовок Host, відправлений клієнтами, не перевірятиметься. <hr /> Якщо заголовок `Host` визначено на сервері, сервер перевірятиме, чи відповідає заголовок `Host`. <hr /> Поточний пріоритет заголовка Host, відправленого клієнтами: `host` > `headers` > `address`"
    },
    "HeadersMapping": {
      "label_headers_row": "Налаштовані HTTP-заголовки",
      "pl_header_key": "Ключ заголовка",
      "pl_header_value": "Значення заголовка"
    },
    "Tcp": {
      "label_accept_proxy_protocol": "Приймати PROXY-протокол",
      "hint_accept_proxy_protocol": "Вказує, чи приймати `PROXY`-протокол. <br /> `PROXY`-протокол використовується для передачі реальної IP-адреси та порту з'єднання. Якщо ви не знайомі з цим, залиште без змін. <br /> Загальновживані рішення для реверсивного проксі (такі як `HAProxy` та `NGINX`) можуть бути налаштовані для відправлення вихідних IP-адрес та портів за допомогою `PROXY`-протоколу. Те саме стосується `VLESS` fallback xver. <br /> Коли встановлено `true`, після встановлення базового TCP-з'єднання клієнт повинен спочатку відправити вихідні IP-адреси та порти за допомогою `PROXY`-протоколу версії 1 або 2, інакше з'єднання буде розірване."
    },
    "SniffingModal": {
      "modal_title": "Перехоплення трафіку",
      "modal_desc": "Перехоплення трафіку використовується переважно у прозорих проксі. Воно може визначити тип протоколу, що використовується в з'єднанні, і потім перенаправити з'єднання до відповідного вихідного проксі.",
      "label_settings": "Налаштування перехоплення",
      "label_enabled": "Перехоплення",
      "label_metadata_only": "Лише метадані",
      "label_dest_override": "Перезапис адреси призначення",
      "label_route_only": "Лише маршрутизація",
      "label_domains_excluded": "Виключені домени",
      "hint_settings": "Налаштування перехоплення",
      "hint_enabled": "Чи увімкнути перехоплення трафіку.",
      "hint_metadata_only": "Якщо увімкнено, для визначення цільової адреси використовується лише метадані з'єднання. У цьому режимі перехоплювач, окрім `fakedns` (включаючи `fakedns+others`), не може бути активований. <hr/> Якщо режим \"лише метадані\" вимкнено, клієнт повинен надіслати дані перед тим, як проксі-сервер фактично встановить з'єднання. Таке поводження несумісне з протоколами, що вимагають, щоб сервер ініціював перше повідомлення, наприклад, SMTP.",
      "hint_dest_override": "Якщо трафік відповідає заданому типу, перезапишіть адресу призначення поточного з'єднання на цільову адресу, зазначену в списку.<hr/> `['fakedns+others']` еквівалентно `['http', 'tls', 'quic', 'fakedns']`, і якщо IP-адреса знаходиться в діапазоні FakeIP, але записи домену не знайдено, для зіставлення будуть використовуватися `http`, `tls` та `quic`. Ця опція діє лише тоді, коли режим \"лише метадані\" вимкнено.",
      "hint_route_only": "Використовуйте перехоплене доменне ім'я лише для маршрутизації, зберігаючи цільову адресу як IP-адресу. Значення за замовчуванням – `false`. Ця опція вимагає увімкнення `destOverride`. <blockquote>Якщо можна забезпечити коректне DNS-розв'язання проксійованого з'єднання, використовуючи режим `routeOnly` разом з увімкненим `destOverride` та встановленням стратегії маршрутизації `domainStrategy` у значення `AsIs`, можна досягти розділення домену та IP без постійного DNS-розв'язання. IP, що використовується при співпадінні з правилом по IP, є оригінальною IP-адресою домену.</blockquote>",
      "hint_domains_excluded": "Список доменних імен. Якщо результат перехоплення трафіку відповідає одному з доменів у цьому списку, цільова адреса не буде змінена. <blockquote><strong>Попередження</strong> Наразі `domainsExcluded` не підтримує зіставлення доменних імен у сенсі маршрутизації. Ця опція може змінитися в майбутньому, і сумісність між версіями не гарантується.</blockquote>",
      "modal_domains_title": "Керувати виключеними доменами",
      "modal_domains_desc": "Якщо результат перехоплення трафіку відповідає доменному імені з цього списку, цільова адреса не буде змінена."
    },
    "GeodatModal": {
      "modal_title": "Менеджер файлів геоданих",
      "modal_desc": "Тут ви можете створювати, редагувати та керувати власними файлами даних geosite/geoip.",
      "loading": "Завантаження...",
      "recompile_all": "перекомпілювати все",
      "compile": "скомпілювати",
      "alert_delete_confirm": "Ви впевнені, що хочете видалити цей файл?",
      "alert_empty_content": "Ну... Гарна спроба, але вам потрібно щось написати в поле вмісту.",
      "option_create_new_file": "Створити новий файл",
      "label_select_file": "Вибрати файл",
      "label_tag": "Тег",
      "label_content": "Вміст",
      "hit_recompile_all": "корисно, коли ви редагуєте файли тегів безпосередньо на вашому роутері і хочете лише перекомпілювати геодані xrayui.",
      "hit_compile": "зберегти вміст файлу тегів і скомпілювати у формат геоданих xrayui.",
      "hint_tag": "Тег файлу геоданих. Цей тег буде використаний у правилах маршрутизації.",
      "hint_content": "Вміст файлу геоданих. <hr/> Масив, де кожен елемент є співставленням домену.<ul><li>Простий рядок: Якщо цей рядок співпадає з будь-якою частиною цільового домену, правило спрацює.</li><li>Регулярний вираз: Починається з **regexp:**, за яким слідує регулярний вираз.</li><li>Піддомен (рекомендується): Починається з **domain:**, за яким слідує домен. Якщо цей домен є цільовим або його піддоменом, правило спрацює. Наприклад, `domain:xray.com` співпадає з `www.xray.com` та `xray.com`, але не з `wxray.com`.</li><li>Точне співпадіння: Починається з **full:**, за яким слідує домен. Якщо цей домен точно співпадає з цільовим, правило спрацює. Наприклад, `full:xray.com` співпадає з `xray.com`, але не з `www.xray.com`.</li><li>Попередньо визначений список доменів: Починається з **geosite:**, за яким слідує ім'я, наприклад, `geosite:google` або `geosite:youtube`. Переконайтеся, що у вас актуальні геодані (натисніть `update metadata` у розділі `маршрутизації`).</li><li>Завантаження доменів з файлу: Форматується як **ext:file:tag**, де файл зберігається в ресурсній директорії і має той же формат, що й geosite.dat. Тег має існувати у файлі.</li></ul>"
    },
    "AllocateModal": {
      "modal_title": "Стратегія розподілу портів",
      "label_settings": "Налаштування",
      "label_strategy": "Стратегія",
      "label_refresh": "Оновити",
      "label_concurrency": "Конкурентність",
      "hint_strategy": "Стратегія розподілу портів.<ul><li>`always`: будуть виділені всі зазначені порти, і Xray прослуховуватиме ці порти.</li><li>`random`: порти будуть випадково вибиратися з діапазону портів кожні кілька хвилин, і буде прослуховуватись кількість портів, що відповідає значенню конкурентності.</li></ul>",
      "hint_refresh": "Інтервал оновлення випадково виділених портів у хвилинах. Мінімальне значення — `2`, рекомендовано встановити `5`. Ця властивість діє лише, коли стратегія встановлена на `random`.",
      "hint_concurrency": "Кількість випадково виділених портів. Мінімальне значення — `1`, а максимальне — одна третина діапазону портів. Рекомендовано встановити `3`."
    },
    "InboundCommon": {
      "label_tag": "Тег",
      "label_listen": "Адреса прослуховування",
      "label_port": "Порт прослуховування",
      "label_port_allocate": "розподіл портів",
      "hint_tag": "Ідентифікатор цього вхідного з'єднання, який використовується для його знаходження в інших конфігураціях.",
      "hint_listen": "Адреса прослуховування, яка може бути IP-адресою або Unix доменним сокетом. Значення за замовчуванням – `0.0.0.0`, що означає прийом з'єднань на всіх мережевих інтерфейсах.<hr/>Можна вказати доступну системну IP-адресу.",
      "hint_port": "Порт прослуховування для вхідних з'єднань. Xray прослуховує вхідні з'єднання на цьому порту."
    },
    "DocodemoDoorInbound": {
      "modal_title": "Dokodemo-Door",
      "modal_desc": "Dokodemo door (Anywhere Door) може прослуховувати локальний порт та перенаправляти всі вхідні дані з цього порту на зазначений порт сервера, досягаючи ефекту пробросу портів.",
      "label_address": "Адреса призначення",
      "label_port": "Порт призначення",
      "label_network": "Мережа",
      "label_follow_redirect": "Слідувати перенаправленню",
      "hint_address": "Адреса, на яку буде перенаправлено трафік. Це може бути IP-адреса, наприклад, `1.2.3.4`, або доменне ім'я, наприклад, `xray.com`.<hr/>Якщо `followRedirect` встановлено на `true`, адреса може бути порожньою.",
      "hint_port": "Зазначений порт на адресі призначення, на який буде перенаправлено трафік. Це числове значення і є **обов’язковим** параметром.",
      "hint_network": "Підтримуваний тип мережевого протоколу. Наприклад, якщо вказано `tcp`, прийматимуться лише TCP-з'єднання. Значення за замовчуванням – `tcp`.",
      "hint_follow_redirect": "Якщо встановлено `true`, dokodemo-door розпізнає дані, перенаправлені через `iptables`, і перенаправить їх до відповідної адреси призначення.<hr/>Дивіться налаштування `tproxy` у розділі «Налаштування транспорту»."
    },
    "OutboundCommon": {
      "label_tag": "Тег",
      "label_send_through": "Відправляти через",
      "hint_tag": "Ідентифікатор цього вихідного з'єднання, який використовується для його знаходження в інших конфігураціях. <blockquote><strong>Небезпечно</strong>: Якщо це поле не порожнє, його значення має бути унікальним серед усіх тегів.</blockquote>",
      "hint_send_through": "IP-адреса, яка використовується для надсилання даних. Ефективно, коли у хоста декілька IP-адрес, а значення за замовчуванням – `0.0.0.0`.<hr/>Дозволено вказувати IPv6 CIDR-блок (наприклад, `114:514:1919:810::/64`), і Xray використовуватиме випадкову IP-адресу з цього блоку для встановлення зовнішніх з'єднань. Необхідно правильно налаштувати доступ до мережі, таблиці маршрутизації та параметри ядра, щоб Xray міг прив'язуватися до будь-якої IP-адреси з цього блоку.<hr/>Для мереж, що використовують NDP, не рекомендується встановлювати підмережу менше `/120`, інакше це може призвести до NDP-флуду та ряду проблем, таких як переповнення кешу сусідів роутера."
    },
    "FreedomOutbound": {
      "modal_title": "Freedom",
      "modal_desc": "Freedom — це вихідний протокол, який можна використовувати для відправлення (звичайних) TCP або UDP даних до будь-якої мережі.",
      "label_domain_strategy": "Стратегія домену",
      "label_redirect": "Адреса перенаправлення",
      "label_proxy_protocol": "PROXY-протокол",
      "label_fragment": "Метод фрагментації пакетів",
      "label_fragment_length": "Довжина фрагмента",
      "label_fragment_interval": "Інтервал між фрагментами",
      "label_udp_noise": "UDP-шум",
      "modal_udp_noise_title": "Керувати записами шуму",
      "modal_udp_noise_entry_title": "Запис шуму",
      "label_udp_noise_type": "Тип",
      "label_udp_noise_packet": "Пакет",
      "label_udp_noise_delay": "Затримка",
      "hint_udp_noise_type": "Підтримуються три типи. <ul> <li>`rand` — генерує випадковий байт</li> <li>`str` — використовує рядок, введений користувачем</li> <li>`base64` — використовує рядок, закодований у base64, введений користувачем</li> </ul>",
      "hint_udp_noise_packet": "Якщо тип встановлено, то <ul> <li>`rand` — задається діапазон, наприклад, `50-100` або одне значення, наприклад, `50`</li> <li>`str` — задається рядок</li> <li>`base64` — задається рядок, закодований у base64</li> </ul>",
      "hint_udp_noise_delay": "Затримка перед відправкою реальних даних (мс). Може бути задана як діапазон, наприклад, `10-20`, або як одне ціле число. Якщо не вказано, значення за замовчуванням – `0`.",
      "hint_domain_strategy": "Якщо адреса призначення є доменним ім'ям, налаштуйте відповідне значення для поведінки Freedom: <ul> <li>`AsIs`: Freedom розв'язує доменне ім'я за допомогою системного DNS-сервера та підключається до нього.</li> <li>`UseIP, UseIPv4, and UseIPv6`: Xray розв'язує доменне ім'я за допомогою вбудованого DNS-сервера та підключається до нього.</li> </ul> <blockquote><strong>Примітка</strong>: При використанні режиму `UseIP` та зазначенні поля `sendThrough` у конфігурації вихідного з'єднання, Freedom автоматично визначатиме необхідний тип IP — `IPv4` чи `IPv6`, виходячи з значення `sendThrough`.</blockquote> <blockquote><strong>Примітка</strong>: При використанні режимів `UseIPv4` або `UseIPv6`, Freedom використовуватиме лише відповідну IP-адресу. Якщо `sendThrough` вказує невідповідну локальну адресу, з'єднання зазнає невдачі.</blockquote>",
      "hint_redirect": "Freedom примусово відправлятиме всі дані на вказану адресу (замість адреси, зазначеної у вхідному з'єднанні). Це рядкове значення, наприклад: `127.0.0.1:80`, `:1234`. Якщо адреса не вказана, наприклад, `:443`, Freedom не змінюватиме початкову адресу призначення. Якщо порт дорівнює `0`, наприклад, `xray.com:0`, Freedom не змінюватиме початковий порт.",
      "hint_proxy_protocol": "Значення `proxyProtocol` представляє версію PROXY-протоколу. Значення за замовчуванням – `0`.",
      "hint_fragment": "Карта ключ-значення, що використовується для контролю фрагментації TCP. У певних випадках вона може обійти цензурну систему, наприклад, обходити чорний список SNI. <ul> <li>`1-3` — сегментація на рівні TCP, що застосовується до перших 1-3 записів даних від клієнта.</li> <li>`tlshello` — фрагментація пакету TLS client hello.</li> </ul>",
      "hint_fragment_length": "Довжина для розбиття",
      "hint_fragment_interval": "Час між фрагментами (мс)",
      "hint_udp_noise": "Масив, який використовується для контролю UDP-шуму, у певних випадках може обходити деякі обмеження протоколів на основі UDP. Xray пройде по цьому масиву та відправить кожен пакет шуму по черзі."
    },
    "BlackholeOutbound": {
      "modal_title": "Чорна діра",
      "modal_desc": "Blackhole – це вихідний протокол передачі даних, який блокує весь вихідний трафік. Використовуючи його разом з налаштуваннями маршрутизації, можна блокувати доступ до певних вебсайтів.",
      "label_response": "Відповідь",
      "hint_response": "Налаштовує дані відповіді для Blackhole.<hr/>Після отримання даних для перенаправлення, Blackhole відправить вказані дані відповіді та закриє з'єднання. Дані для перенаправлення будуть відкинуті. Якщо це поле не задане, Blackhole просто закриє з'єднання.<ul><li>`none`: Blackhole просто закриває з'єднання.</li><li>`http`: Blackhole відправить простий пакет `HTTP 403` як відповідь і потім закриє з'єднання.</li></ul>"
    },
    "VlessOutbound": {
      "modal_title": "VLESS",
      "modal_desc": "VLESS – це безстанова легка транспортна технологія, яка розділена на вхідну та вихідну частини і може використовуватися як міст між клієнтами та серверами Xray. На відміну від VMess, VLESS не залежить від системного часу, а метод автентифікації також базується на UUID.",
      "label_address": "Адреса сервера",
      "label_port": "Порт сервера",
      "hint_address": "Адреса сервера, що вказує на сервер, підтримує доменні імена, IPv4 і IPv6.",
      "hint_port": "Порт сервера, зазвичай той самий, на якому сервер прослуховує з'єднання."
    },
    "VmessOutbound": {
      "modal_title": "VMess",
      "modal_desc": "VMess – це зашифрована транспортна технологія, яка зазвичай використовується як міст між клієнтами та серверами Xray.",
      "label_address": "Адреса сервера",
      "label_port": "Порт сервера",
      "hint_address": "Адреса сервера, що вказує на сервер, підтримує доменні імена, IPv4 і IPv6.",
      "hint_port": "Порт сервера, зазвичай той самий, на якому сервер прослуховує з'єднання."
    },
    "CertificatesModal": {
      "modal_title": "Керування TLS-сертифікатом",
      "label_ocsp_stapling": "OCSP stapling",
      "label_one_time_loading": "Однократне завантаження",
      "label_usage": "Використання",
      "label_build_chain": "Побудова ланцюга",
      "label_certificate_file": "Шлях до файлу .crt",
      "label_certificate_content": "Зміст сертифіката",
      "label_key_file": "Шлях до файлу .key",
      "label_key_content": "Зміст ключа",
      "hint_ocsp_stapling": "Інтервал оновлення OCSP stapling у секундах для гарячої перезавантаження сертифіката. Значення за замовчуванням – `3600`, тобто одна година.",
      "hint_one_time_loading": "Завантажувати лише один раз. Якщо встановлено `true`, буде відключено гарячу перезавантаження сертифіката та функцію OCSP stapling. <blockquote><strong>Попередження</strong>: При встановленні `true` OCSP stapling буде відключено.</blockquote>",
      "hint_usage": "Використання сертифіката, значення за замовчуванням – `encipherment`.<ul><li>`encipherment`: сертифікат використовується для TLS-автентифікації та шифрування.</li><li>`verify`: сертифікат використовується для перевірки віддаленого TLS-сертифіката. При використанні цієї опції поточний сертифікат має бути сертифікатом ЦС.</li><li>`issue`: сертифікат використовується для видачі інших сертифікатів. При використанні цієї опції поточний сертифікат має бути сертифікатом ЦС.</li></ul>",
      "hint_build_chain": "Діє лише, коли використання встановлено як `issue`. Якщо встановлено `true`, до кінцевого сертифіката буде додано сертифікат ЦС як ланцюжок при видачі сертифікатів. <blockquote>Кореневі сертифікати не повинні бути вбудовані в ланцюжок сертифікатів. Ця опція застосовується лише, коли підписуючий сертифікат ЦС є проміжним сертифікатом.</blockquote>",
      "hint_certificate_file": "Шлях до файлу сертифіката. Якщо зміст сертифіката порожній, його буде прочитано з файлу.",
      "hint_certificate_content": "Зміст сертифіката. Якщо шлях до файлу сертифіката порожній, його буде прочитано з цього поля.",
      "hint_key_file": "Шлях до файлу ключа. Якщо зміст ключа порожній, його буде прочитано з файлу.",
      "hint_key_content": "Зміст ключа. Якщо шлях до файлу ключа порожній, його буде прочитано з цього поля."
    },
    "DnsServersModal": {
      "modal_desc": "Список DNS-серверів, який може містити як DNS-адреси (у вигляді рядків), так і об’єкти DnsServerObjects (розширені опції).",
      "no_hosts_defined": "Хости не задані",
      "advanced": "розширені",
      "server": "Сервер",
      "list": "Список визначених серверів",
      "modal_server_title": "Розширені опції",
      "modal_server_title2": "Налаштування сервера",
      "label_address": "Адреса",
      "label_port": "Порт",
      "label_domains": "Домени",
      "label_client_ip": "IP клієнта",
      "label_expected_ips": "Очікувані IP",
      "label_skip_fallback": "Пропустити резерв",
      "hint_client_ip": "Використовується для повідомлення сервера про вказане розташування IP під час DNS-запитів. Не може бути приватною адресою.",
      "hint_domains": "Список доменних імен. Домени з цього списку спочатку запитуються через цей сервер. Формат доменних імен такий же, як у конфігурації маршрутизації.",
      "hint_port": "Номер порту DNS-сервера, наприклад, 53. Якщо не вказано, значення за замовчуванням – 53. Цей параметр не застосовується при використанні режимів DOH, DOHL або DOQL, а нестандартні порти слід вказувати у URL.",
      "hint_expected_ips": "Список діапазонів IP у тому ж форматі, що й у конфігурації маршрутизації. Якщо цей параметр налаштовано, Xray DNS перевірятиме повернені IP і повертатиме лише ті, що входять до списку expectIPs. Якщо параметр не налаштовано, IP повертається як є.",
      "hint_skip_fallback": "Значення true означає, що цей сервер буде пропущено при виконанні резервних DNS-запитів, а значення за замовчуванням – false, тобто сервер не пропускається.",
      "label_domain_rules": "Пов’язані правила",
      "modal_rules_list": "Пов’язані правила",
      "hint_domains_disabled": "Домени для цього сервера керуються на основі пов’язаних правил.",
      "hint_domain_rules": "Можна пов’язати конкретні правила з цим сервером. Коли правило пов’язане, будуть використовуватись його домени."
    },
    "ProcessUptime": {
      "label": "Час роботи процесу X-RAY Core",
      "formatted_time": "Час роботи: {0}д {1}г {2}х {3}с"
    },
    "XrayCoreVersionModal": {
      "modal_title": "Оновлення X-RAY Core",
      "modal_desc": "Виберіть версію для перемикання:",
      "switch": "Перемкнутися на цю версію"
    },
    "ReverseProxy": {
      "title": "Зворотний проксі",
      "hint_title": "Зворотний проксі перенаправляє трафік від сервера до клієнта. Цей процес називається зворотним перенаправленням трафіку.",
      "label_bridges": "Мости (Bridges)",
      "label_portals": "Портали (Portals)",
      "hint_bridges": "Масив, де кожен елемент є мостом. Конфігурація кожного моста є об'єктом `BridgeObject`.",
      "hint_portals": "Масив, де кожен елемент є порталом. Конфігурація кожного порталу є об'єктом `PortalObject`."
    },
    "ReverseItemsModal": {
      "modal_title": "Елементи зворотного проксі",
      "modal_title2": "Список"
    },
    "Profiles": {
      "manager": "Менеджер профілів",
      "modal_title": "Керування профілями",
      "hint": "Виберіть конфігураційний профіль зі списку нижче. Цей список автоматично заповнюється всіма JSON-файлами з каталогу `/opt/etc/xray`. Після вибору профілю ви також можете керувати списком, додаючи або видаляючи конфігураційні файли за потребою."
    },
    "ClientsOnline": {
      "title": "Клієнти онлайн",
      "label_client": "Клієнт",
      "label_ip": "IP",
      "message_logs": "Щоб перевірити онлайн-користувачів, потрібно увімкнути логування xray. Бажаєте його увімкнути?",
      "enable_logs": "Увімкнути логування",
      "online": "онлайн",
      "noone_is_online": "Ніхто не в мережі"
    },
    "Backup": {
      "manager": "Керування резервними копіями",
      "backup": "резервне копіювання",
      "clear": "очистити",
      "hint": "Резервне копіювання конфігураційних файлів xray/xrayui.",
      "clear_confirm": "Ви впевнені, що хочете видалити всі резервні копії?",
      "restore_confirm": "Ви впевнені, що хочете відновити цю резервну копію?\nУвага: поточна конфігурація буде перезаписана.\n\nРекомендується створити резервну копію перед відновленням.",
      "download": "завантажити",
      "restore": "відновити"
    }
  }
}
